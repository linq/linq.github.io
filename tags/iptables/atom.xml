<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="zh">
    <title> - iptables</title>
    <link href="https://linq.github.io/tags/iptables/atom.xml" rel="self" type="application/atom+xml"/>
    <link href="https://linq.github.io"/>
    <generator uri="https://www.getzola.org/">Zola</generator>
    <updated>2024-03-16T00:00:00+00:00</updated>
    <id>https://linq.github.io/tags/iptables/atom.xml</id>
    <entry xml:lang="zh">
        <title>iptables的表、链、规则</title>
        <published>2024-03-16T00:00:00+00:00</published>
        <updated>2024-03-16T00:00:00+00:00</updated>
        <author>
          <name>Unknown</name>
        </author>
        <link rel="alternate" href="https://linq.github.io/posts/iptables/" type="text/html"/>
        <id>https://linq.github.io/posts/iptables/</id>
        
        <content type="html">&lt;p&gt;&lt;code&gt;iptables -t nat -I POSTROUTING -o eth0 -j MASQUERADE&lt;&#x2F;code&gt;
首先我们解释下这条命令的功能，这条命令的作用是配置 &lt;code&gt;NAT&lt;&#x2F;code&gt;，以便所有通过 eth0 接口发送到网络的 IP 包都（伪装）修改它们的源 IP 地址。通常用于私有网络连接到互联网的情况，使得私有网络内的所有机器对外部网络只显示一个公共的 IP 地址。&lt;&#x2F;p&gt;
&lt;p&gt;简单来看就是把当前设备当成路由器，把所有通过当前设备（eth0 网卡）转发出去的数据的源 IP 改写成当前设备的 IP。&lt;&#x2F;p&gt;
&lt;p&gt;首先是这里的改写功能在命令的哪部分体现的？是 &lt;code&gt;-j MASQUERADE&lt;&#x2F;code&gt;，这里的 &lt;code&gt;MASQUERADE&lt;&#x2F;code&gt; 是 &lt;code&gt;iptables&lt;&#x2F;code&gt; 预置的行为之一，作用是自动的修改源或目标的 IP 来做 &lt;code&gt;NAT&lt;&#x2F;code&gt;。其它的常见行为还有：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;DROP&lt;&#x2F;strong&gt;：直接将数据包丢弃。&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;REJECT&lt;&#x2F;strong&gt;：给客户端返回 Connection Refused 或 Destination Unreachable 报文。 &lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;QUEUE&lt;&#x2F;strong&gt;：将数据包放入用户空间的队列，供用户空间的程序处理。&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;RETURN&lt;&#x2F;strong&gt;：跳出当前链，该链里后续的规则不再执行。&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;ACCEPT&lt;&#x2F;strong&gt;：同意数据包通过，继续执行后续的规则。&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;JUMP&lt;&#x2F;strong&gt;：跳转到其他用户自定义的链继续执行。&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;REDIRECT&lt;&#x2F;strong&gt;：在本机做端口映射。&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;MASQUERADE&lt;&#x2F;strong&gt;：地址伪装，自动用修改源或目标的 IP 地址来做 NAT。&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;LOG&lt;&#x2F;strong&gt;：在&#x2F;var&#x2F;log&#x2F;messages 文件中记录日志信息。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;iptables 所有的命令最终是要执行上面的行为。&lt;&#x2F;p&gt;
&lt;p&gt;然后再看下前面的参数 &lt;code&gt;-o eth0&lt;&#x2F;code&gt;，这个选项指定只有通过 &lt;code&gt;eth0&lt;&#x2F;code&gt; 网卡离开本机的数据包生效。相对于对后面执行的行为有一个限定条件，而这个条件➕行为就组成了 iptables 的规则。&lt;&#x2F;p&gt;
&lt;p&gt;iptables 中每条规则都包含了一组匹配条件和一个动作（称为“目标“）。当数据包在链上的流程中和规则的匹配条件相符时，将对其执行规定的动作，如接受（&lt;code&gt;ACCEPT&lt;&#x2F;code&gt;）、拒绝（&lt;code&gt;REJECT&lt;&#x2F;code&gt;）、丢弃（&lt;code&gt;DROP&lt;&#x2F;code&gt;）、转发（&lt;code&gt;FORWARD&lt;&#x2F;code&gt;）等。简单来理解规则就是 &lt;code&gt;if 满足 xxx 条件, then 执行 yyy 行为&lt;&#x2F;code&gt;。&lt;&#x2F;p&gt;
&lt;p&gt;然后在往前看 &lt;code&gt;-I POSTROUTING&lt;&#x2F;code&gt;，这里的 &lt;code&gt;POSTROUTING&lt;&#x2F;code&gt; 是 &lt;code&gt;iptables&lt;&#x2F;code&gt; 的一个链，什么是链呢，可以认为就是 &lt;code&gt;iptables&lt;&#x2F;code&gt; 中的规则的有序集合。&lt;code&gt;iptables&lt;&#x2F;code&gt; 已经提前定义好多个内置的链，我们要做的是把规则放到链中。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;code&gt;iptables&lt;&#x2F;code&gt; 预定义了 5 个链，这些链就代表数据包在网络栈中经过的不同点。&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;PREROUTING&lt;&#x2F;strong&gt;：处理进入网络接口但还未被路由选择的数据包&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;INPUT&lt;&#x2F;strong&gt;：处理即将送往本地进程的数据包&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;FORWARD&lt;&#x2F;strong&gt;：处理经过本机（当前的Linux系统）正在路由到其他目的地的所有数据包&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;OUTPUT&lt;&#x2F;strong&gt;：处理本地产生要发送出去的数据包&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;POSTROUTING&lt;&#x2F;strong&gt;：处理即将离开本机的所有数据包，并且处理发生在路由决策之后&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;所以我们的命令是把规则加入到 &lt;code&gt;POSTROUTING&lt;&#x2F;code&gt; 中，也就是在数据包即将离开本机的时候处理。&lt;&#x2F;p&gt;
&lt;p&gt;最后来看下 &lt;code&gt;-t nat&lt;&#x2F;code&gt;，这里指定了 iptables 的 nat 表，那什么是表呢，我们可以认为 iptables 的表就是链的分类集合，通常根据处理数据包的阶段或者目的进行分类。常见的表有 filter（用于过滤数据包），nat（用于网络地址转换），mangle（用于特殊的包处理），和 raw（用于决定数据包是否会被状态跟踪）。&lt;&#x2F;p&gt;
&lt;p&gt;这里可能会有个疑问，貌似通过规则、链好像能实现基本的数据包处理了，为什么还要引入表呢？这里其实是为了管理方便，想象下如果只有链，我需要对发送出去的数据包做不同的处理，那可能就是在一个 OUTPUT 链中有维护 n 条处理规则，到后期维护成本就会很高。而通过 &lt;code&gt;iptables&lt;&#x2F;code&gt; 预分类好的表，我们根据处理阶段就知道应该添加到哪张表中，整个规则的维护都会更加的清晰和高效。&lt;&#x2F;p&gt;
&lt;p&gt;来总结下 &lt;code&gt;iptables&lt;&#x2F;code&gt; 中表、链、规则的关系，表是链的分类集合，内部包括链；而链是规则的有序集合，内部包括规则。&lt;&#x2F;p&gt;
&lt;p&gt;最后我们再来看下 &lt;code&gt;iptables&lt;&#x2F;code&gt; 是什么，&lt;code&gt;iptables&lt;&#x2F;code&gt; 是 &lt;code&gt;Linux&lt;&#x2F;code&gt; 提供的一个命令行工具，主要用于配置内核提供的 &lt;code&gt;netfilter&lt;&#x2F;code&gt; 防火墙功能。也就是说 &lt;code&gt;iptables&lt;&#x2F;code&gt; 只是一个配置工具，底层核心能力其实都是 &lt;code&gt;netfilter&lt;&#x2F;code&gt; 来实现的，包括核心的预定义链其实都是关联 &lt;code&gt;netfilter&lt;&#x2F;code&gt; 的五个同名钩子。不过 &lt;code&gt;netfilter&lt;&#x2F;code&gt; 要通过程序编码才够能使用，并不适合系统管理员用来日常运维，而 &lt;code&gt;iptables&lt;&#x2F;code&gt; 的价值就是以配置去实现原本用 &lt;code&gt;netfilter&lt;&#x2F;code&gt; 编码才能做到的事情。&lt;&#x2F;p&gt;
&lt;p&gt;最后贴下网络栈中 netfilter 5 个钩子的流程。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;linq.github.io&#x2F;posts&#x2F;iptables&#x2F;netfilter-hook.webp&quot; alt=&quot;netfilter hooks&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.liuvv.com&#x2F;p&#x2F;a8480986.html&quot;&gt;参考&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
</content>
        
    </entry>
</feed>
