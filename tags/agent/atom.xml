<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="zh">
    <title> - Agent</title>
    <link href="https://linq.github.io/tags/agent/atom.xml" rel="self" type="application/atom+xml"/>
    <link href="https://linq.github.io"/>
    <generator uri="https://www.getzola.org/">Zola</generator>
    <updated>2025-01-17T00:00:00+00:00</updated>
    <id>https://linq.github.io/tags/agent/atom.xml</id>
    <entry xml:lang="zh">
        <title>Gorilla：连接大量 API 的大型语言模型</title>
        <published>2025-01-17T00:00:00+00:00</published>
        <updated>2025-01-17T00:00:00+00:00</updated>
        <author>
          <name>Unknown</name>
        </author>
        <link rel="alternate" href="https://linq.github.io/posts/gorilla/" type="text/html"/>
        <id>https://linq.github.io/posts/gorilla/</id>
        
        <content type="html">&lt;blockquote&gt;
&lt;p&gt;这篇文章介绍了 Berkeley 函数调用排行榜(BFCL),这是首个对大语言模型(LLM)函数调用能力的全面评估基准。文章详细阐述了:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;评估数据集的构成(包含 2000 个测试用例,涵盖 Python、Java、JavaScript、REST API 等多种语言)&lt;&#x2F;li&gt;
&lt;li&gt;评估方法(包括 AST 分析和可执行函数验证)&lt;&#x2F;li&gt;
&lt;li&gt;不同类型的函数调用测试(简单、多重、并行等场景)&lt;&#x2F;li&gt;
&lt;li&gt;各个模型的成本和延迟数据&lt;&#x2F;li&gt;
&lt;li&gt;常见的函数调用错误模式&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;研究发现,在简单函数调用场景下,经过微调的开源模型可以达到与专有模型相当的效果。文章还介绍了他们开发的开源模型 Gorilla Open Functions v2。&lt;&#x2F;p&gt;
&lt;p&gt;原文链接：https:&#x2F;&#x2F;gorilla.cs.berkeley.edu&#x2F;blogs&#x2F;8_berkeley_function_calling_leaderboard.html&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;除了聊天之外，将大型语言模型（LLM）集成到许多应用程序和软件中（例如，Langchain、Llama Index、AutoGPT、Voyager）也变得越来越普遍。像 GPT、Gemini、Llama、Mistral 等模型，已通过函数调用（也称为工具调用）能力展示了这方面的巨大潜力。&lt;&#x2F;p&gt;
&lt;p&gt;我们提出了伯克利函数调用排行榜（BFCL），这是对 LLM 调用函数和工具的能力进行的首次全面评估。我们从实践经验中构建了这个数据集，使其能代表大多数用户的函数调用场景，例如在智能体中或作为企业工作流的一部分等。我们考虑了各种形式的函数调用，包括并行调用(一个函数输入，多个函数输出)和多重调用 (多个函数输入，一个函数输出)，涵盖了 Java、JavaScript 等多种编程语言。此外，我们还会执行这些函数来测试模型，并评估模型在没有合适函数可用时是否能够正确地避免选择函数。另外，排行榜现在还包含了所有不同模型的成本和延迟数据!&lt;&#x2F;p&gt;
&lt;p&gt;2024 年 8 月 19 日，我们发布了 BFCL V2 数据集，其特点是包含企业贡献的数据，解决了偏见和数据污染等问题，并专注于动态的真实场景。查看 &lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;gorilla.cs.berkeley.edu&#x2F;blogs&#x2F;12_bfcl_v2_live.html&quot;&gt;BFCL V2 · Live 博客文章&lt;&#x2F;a&gt;了解更多详情。&lt;&#x2F;p&gt;
&lt;p&gt;2024 年 9 月 19 日，我们发布了 BFCL V3 数据集，其特点是包含多轮和多步骤函数调用评估。查看 &lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;gorilla.cs.berkeley.edu&#x2F;blogs&#x2F;13_bfcl_v3_multi_turn.html&quot;&gt;BFCL V3 博客文章&lt;&#x2F;a&gt;了解更多详情!&lt;&#x2F;p&gt;
&lt;p&gt;快速链接:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;在线排行榜:&lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;gorilla.cs.berkeley.edu&#x2F;leaderboard.html&quot;&gt;网站&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;BFCL 评估数据集:&lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;huggingface.co&#x2F;datasets&#x2F;gorilla-llm&#x2F;Berkeley-Function-Calling-Leaderboard&quot;&gt;HuggingFace 数据集 🤗&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;BFCL V2 Live: &lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;gorilla.cs.berkeley.edu&#x2F;blogs&#x2F;12_bfcl_v2_live.html&quot;&gt;博客文章&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;Gradio 演示:&lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;huggingface.co&#x2F;spaces&#x2F;gorilla-llm&#x2F;berkeley-function-calling-leaderboard&quot;&gt;HuggingFace Space 🤗&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;可复现性 :&lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;ShishirPatil&#x2F;gorilla&#x2F;tree&#x2F;main&#x2F;berkeley-function-call-leaderboard&quot;&gt;Github 代码&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;OpenFunctions-v2 (6.91B) 在 HuggingFace 🤗:&lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;huggingface.co&#x2F;gorilla-llm&#x2F;gorilla-openfunctions-v2&quot;&gt;gorilla-llm&#x2F;gorilla-openfunctions-v2&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h3 id=&quot;berkeley-han-shu-diao-yong-pai-xing-bang-trophy&quot;&gt;Berkeley 函数调用排行榜 🏆&lt;&#x2F;h3&gt;
&lt;p&gt;&lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;gorilla.cs.berkeley.edu&#x2F;leaderboard.html&quot;&gt;Berkeley 函数调用排行榜&lt;&#x2F;a&gt; (BFCL) 旨在对不同 LLM 的函数调用能力进行全面研究。它包含 2000 个问题-函数-答案对，涵盖多种语言 (Python、Java、JavaScript、REST API)，多样化的应用领域和复杂用例 (多函数调用，LLM 需要从多个提供的函数中选择一个或多个函数；以及并行函数调用，LLM 需要同时进行多个函数调用)。我们还研究了函数相关性检测，以确定当提供的函数不适合回答用户问题时模型会如何反应(在这种情况下会提供“错误信息“)。更具体地说，&lt;strong&gt;BFCL 包含 100 个 Java、50 个 JavaScript、70 个 REST API、100 个 SQL 和 1，680 个 Python 测试，涵盖了简单、并行、多重、可执行函数调用场景以及函数相关性检测&lt;&#x2F;strong&gt;。&lt;&#x2F;p&gt;
&lt;p&gt;如下图所示的排行榜中，我们可以看到 OpenAI 的最新 GPT-4 版本领先评估，紧随其后的是开源模型 (OpenFunctions-v2)、Mistral AI 的 Mistral-medium 模型和 Anthropic 的 Claude-2.1。这篇博文包含了更多关于数据集、评估方法、常见失败模式等信息!&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;oss-ata.alibaba.com&#x2F;article&#x2F;2025&#x2F;01&#x2F;050a87a4-df1a-4712-9b82-cadfcb2e4131.png&quot; alt=&quot;Berkeley 函数调用排行榜 (BFCL)&quot; &#x2F;&gt; &lt;em&gt;LLM 在 &lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;gorilla.cs.berkeley.edu&#x2F;leaderboard.html&quot;&gt;Berkeley 函数调用排行榜&lt;&#x2F;a&gt; (BFCL) 上的表现&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;p&gt;为了改进我们对结果的理解和可视化，我们引入了一个交互式的轮辐图工具，允许用户比较各种模型。这种比较分为九个不同的类别：函数相关性检测、AST(抽象语法树)分析，以及在简单、多重和并行多重函数场景下的执行函数调用验证。通过这种方法，可以清楚地看到测试揭示了模型的不理想表现。具体来说，在简单函数调用方面，专有和开源模型表现相当。然而，在处理多重和并行函数调用时，GPT 系列模型表现优于开源对手。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;oss-ata.alibaba.com&#x2F;article&#x2F;2025&#x2F;01&#x2F;e134c84f-4d69-435b-9bf7-414b7b10c9ef.gif&quot; alt=&quot;Berkeley 函数调用排行榜 (BFCL) 轮辐图&quot; &#x2F;&gt; &lt;em&gt;使用 &lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;gorilla.cs.berkeley.edu&#x2F;leaderboard.html&quot;&gt;Berkeley 函数调用排行榜&lt;&#x2F;a&gt; (BFCL) 轮辐图进行的详细分析&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;h3 id=&quot;shu-ju-ji-gou-cheng&quot;&gt;数据集构成&lt;&#x2F;h3&gt;
&lt;p&gt;Gorilla OpenFunctions 评估数据集从之前的 &lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;gorilla.cs.berkeley.edu&#x2F;blogs&#x2F;4_open_functions.html&quot;&gt;&lt;code&gt;OpenFunctions-v0&lt;&#x2F;code&gt; 的 100 个数据点&lt;&#x2F;a&gt;增长到了 2，000 个数据点！除了质量改进外，扩展后的数据集在以下方面展示了多样性:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;函数文档的领域&lt;&#x2F;li&gt;
&lt;li&gt;函数文档和函数调用对的数量&lt;&#x2F;li&gt;
&lt;li&gt;不同编程语言的数据类型&lt;&#x2F;li&gt;
&lt;li&gt;真实世界示例的可执行性&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;我们的评估 JSON 函数是从不同网站来源抓取和生成的。我们有意包含了与 &lt;code&gt;数学-代数&lt;&#x2F;code&gt;、&lt;code&gt;体育-足球&lt;&#x2F;code&gt;、&lt;code&gt;金融-抵押&lt;&#x2F;code&gt; 等相关的函数领域。我们在通用评估中包含了 40 个函数子领域。这使我们能够理解模型在计算、云计算等数据丰富领域以及体育、法律等小众领域的表现。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;oss-ata.alibaba.com&#x2F;article&#x2F;2025&#x2F;01&#x2F;f63711f2-7099-4852-887d-e28f6181fbe0.png&quot; alt=&quot;Gorilla 输入和输出&quot; &#x2F;&gt;&lt;em&gt;&lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;gorilla.cs.berkeley.edu&#x2F;leaderboard.html&quot;&gt;伯克利函数调用排行榜&lt;&#x2F;a&gt; (BFCL) 数据组成&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;h3 id=&quot;ping-gu-lei-bie-bar-chart&quot;&gt;评估类别 📊&lt;&#x2F;h3&gt;
&lt;p&gt;我们将大部分评估分为两个类别:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Python&lt;&#x2F;strong&gt;: 简单函数、多重函数、并行函数、并行多重函数&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;非 Python&lt;&#x2F;strong&gt;: 聊天能力、函数相关性检测、REST API、SQL、Java、Javascript&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h5 id=&quot;python-ping-gu&quot;&gt;Python 评估&lt;&#x2F;h5&gt;
&lt;p&gt;**简单函数:**单函数评估包含最简单但最常见的格式，用户提供单个 JSON 函数文档，且只会调用一个函数。&lt;&#x2F;p&gt;
&lt;p&gt;**多重函数:**多重函数类别包含一个用户问题，该问题只从 2 到 4 个 JSON 函数文档中调用一个函数。模型需要能够根据用户提供的上下文选择最佳函数来调用。&lt;&#x2F;p&gt;
&lt;p&gt;**并行函数:**并行函数定义为通过一个用户查询并行调用多个函数。模型需要理解需要进行多少次函数调用，问题可以是单句或多句。&lt;&#x2F;p&gt;
&lt;p&gt;**并行多重函数:**并行多重函数是并行函数和多重函数的组合。换句话说，模型会收到多个函数文档，每个相应的函数调用将被调用零次或多次。&lt;&#x2F;p&gt;
&lt;p&gt;每个类别都有 AST 和相应的可执行评估。在可执行评估数据中，我们手动编写了 Python 函数，这些函数从免费的 REST API 端点 (例如获取天气) 和直接计算的函数 (例如线性回归) 中获取灵感。可执行类别旨在了解函数调用生成是否能在现实世界的应用程序中稳定使用函数调用。&lt;&#x2F;p&gt;
&lt;h5 id=&quot;fei-python-ping-gu&quot;&gt;非 Python 评估&lt;&#x2F;h5&gt;
&lt;p&gt;虽然前面的类别构成了我们评估的主要部分，但我们还包括了其他特定类别，即聊天能力、函数相关性检测、REST API、SQL、Java 和 JavaScript，以评估模型在不同场景下的表现、对多种编程语言的支持，以及对不相关问题和函数文档的适应能力。&lt;&#x2F;p&gt;
&lt;p&gt;**聊天能力:**在聊天能力中，我们设计了不传入函数的场景，用户提出一般性问题 ⸺ 这类似于将模型用作通用聊天机器人。我们评估模型是否能够输出聊天消息并认识到不需要调用任何函数。注意与 “相关性” 的区别，在 “相关性” 中，模型还需要评估任何函数输入是否相关。我们将此类别用于内部模型评估，并从实时排行榜中排除统计数据。我们目前正在努力改进聊天能力的评估，确保聊天与用户请求相关且连贯，并欢迎社区提供建议和反馈。&lt;&#x2F;p&gt;
&lt;p&gt;**函数相关性检测:**在函数相关性检测中，我们设计了场景，其中没有任何提供的函数是相关的且应该被调用的。我们期望模型的输出是没有函数调用。这种场景可以洞察模型是否会在缺乏函数信息或用户指令的情况下，对其函数和参数产生幻觉来生成函数代码。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;REST API:&lt;&#x2F;strong&gt; 现实世界中的大多数 API 调用都是 REST API 调用。Python 主要通过 Python requests 库中包含的 &lt;code&gt;requests.get()&lt;&#x2F;code&gt;、&lt;code&gt;requests.post()&lt;&#x2F;code&gt;、&lt;code&gt;requests.delete()&lt;&#x2F;code&gt; 等进行 REST API 调用。GET 请求是现实世界中最常用的。因此，我们包括了真实世界的 GET 请求，以测试模型通过复杂函数文档生成可执行 REST API 调用的能力，使用 &lt;code&gt;requests.get()&lt;&#x2F;code&gt; 以及 API 的硬编码 URL 和函数及其参数的描述。&lt;&#x2F;p&gt;
&lt;p&gt;我们的评估包括两种变体。第一种需要在 URL 中传递参数，称为路径参数，例如 &lt;code&gt;GET &#x2F;api&#x2F;v3&#x2F;PublicHolidays&#x2F;{Year}&#x2F;{CountryCode}&lt;&#x2F;code&gt; 中的 &lt;code&gt;{Year}&lt;&#x2F;code&gt; 和 &lt;code&gt;{CountryCode}&lt;&#x2F;code&gt;。第二种需要模型将参数作为键值对放入 &lt;code&gt;requests.get(.)&lt;&#x2F;code&gt; 的 &lt;code&gt;params&lt;&#x2F;code&gt; 和&#x2F;或 &lt;code&gt;headers&lt;&#x2F;code&gt; 中。例如，函数调用中的 &lt;code&gt;params={&#x27;lang&#x27;: &#x27;fr&#x27;}&lt;&#x2F;code&gt;。模型并不会被告知将要进行哪种类型的 REST API 调用，而是需要自行决定如何调用。&lt;&#x2F;p&gt;
&lt;p&gt;对于 REST API，我们使用可执行评估来检查可执行输出的有效执行、响应类型和响应 JSON 键的一致性。在 AST 方面，我们选择不对 REST 执行 AST 评估，主要是因为复杂定义的 API 可能有大量可能的答案，枚举所有可能的答案是很耗费资源的。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;SQL:&lt;&#x2F;strong&gt; SQL 评估数据包括我们自定义的 &lt;code&gt;sql.execute&lt;&#x2F;code&gt; 函数，其中包含 sql_keyword、table_name、columns 和 conditions。这四个参数提供了构造简单 SQL 查询所需的信息，如 &lt;code&gt;SELECT column_A from table_B where column_C == D&lt;&#x2F;code&gt;。通过这种方式，我们想看看是否可以通过函数调用可靠地构造和使用 SQL 查询，而不是训练特定的 SQL 模型。在我们的评估数据集中，我们限制了场景并支持简单的关键字，包括 &lt;code&gt;SELECT&lt;&#x2F;code&gt;、&lt;code&gt;INSERT INTO&lt;&#x2F;code&gt;、&lt;code&gt;UPDATE&lt;&#x2F;code&gt;、&lt;code&gt;DELETE&lt;&#x2F;code&gt; 和 &lt;code&gt;CREATE&lt;&#x2F;code&gt;。我们包含了 100 个用于 SQL AST 评估的示例。注意，SQL AST 评估不会显示在我们的排行榜计算中。我们使用 SQL 评估来测试函数调用对于未包含在 Gorilla OpenFunctions-v2 训练集中的编程语言的泛化能力。由于构造 SQL 函数调用实现相同结果的方法有多种，我们选择从 BFCL 的 AST 评估中排除 SQL 性能。我们目前正在努力改进 SQL 评估，并欢迎社区提供建议和反馈。因此，当前排行榜中已省略 SQL，为后续迭代中更全面的评估铺平道路。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Java + Javascript:&lt;&#x2F;strong&gt; 尽管函数调用格式在大多数编程语言中都是相同的，但每种编程语言都有特定的类型。例如，Java 有 &lt;code&gt;HashMap&lt;&#x2F;code&gt; 类型。这个测试类别的目标是了解函数调用模型不仅可以扩展到 Python 类型，还可以扩展到所有特定语言的类型。我们包含了 100 个用于 Java AST 评估的示例和 70 个用于 Javascript AST 评估的示例。&lt;&#x2F;p&gt;
&lt;p&gt;上述类别提供了不同模型在流行的 API 调用场景中的性能洞察，为函数调用模型的潜力提供了有价值的视角。&lt;&#x2F;p&gt;
&lt;h5 id=&quot;pai-xing-bang-ping-gu-lei-bie&quot;&gt;排行榜评估类别&lt;&#x2F;h5&gt;
&lt;p&gt;我们对现有类别进行了层次分类，在 Berkeley 函数调用排行榜 BFCL 中展示了九个类别，这些类别按评估方法(AST 或执行)和函数类型(简单、并行、多重、并行多重函数)进行分组。这里，我们展示了一个表格，组织了每个排行榜类别的评估数据点计数，这些类别由博客中列出的更细粒度的类别组成。具体来说，我们将 REST 可执行评估归类为“简单函数(通过执行 API 评估)“，因为我们考虑了调用一个 REST API 的情况。对于 Java + Javascript 评估，我们将其归类为“简单函数(抽象语法树 (AST) 评估)”，因为我们当前版本的评估集没有包含多种编程语言的多重、并行和并行多重情况。&lt;&#x2F;p&gt;
&lt;p&gt;BFCL 中显示的九个类别的最终计数以及更细粒度类型的组成如下表所示：&lt;&#x2F;p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;Abstract Syntax Tree (AST) Evaluation 🌳&lt;&#x2F;th&gt;&lt;th&gt;&lt;&#x2F;th&gt;&lt;th&gt;&lt;&#x2F;th&gt;&lt;th&gt;&lt;&#x2F;th&gt;&lt;th&gt;Evaluation by Executing APIs ⚙️&lt;&#x2F;th&gt;&lt;th&gt;&lt;&#x2F;th&gt;&lt;th&gt;&lt;&#x2F;th&gt;&lt;th&gt;&lt;&#x2F;th&gt;&lt;th&gt;Relevance Detection&lt;&#x2F;th&gt;&lt;&#x2F;tr&gt;&lt;&#x2F;thead&gt;&lt;tbody&gt;
&lt;tr&gt;&lt;td&gt;Simple Function&lt;&#x2F;td&gt;&lt;td&gt;Multiple Functions&lt;&#x2F;td&gt;&lt;td&gt;Parallel Functions&lt;&#x2F;td&gt;&lt;td&gt;Parallel Multiple&lt;&#x2F;td&gt;&lt;td&gt;Simple Function&lt;&#x2F;td&gt;&lt;td&gt;Multiple Functions&lt;&#x2F;td&gt;&lt;td&gt;Parallel Functions&lt;&#x2F;td&gt;&lt;td&gt;Parallel Multiple&lt;&#x2F;td&gt;&lt;td&gt;&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;Py: 400Java: 100JS: 50&lt;&#x2F;td&gt;&lt;td&gt;Py: 200&lt;&#x2F;td&gt;&lt;td&gt;Py: 200&lt;&#x2F;td&gt;&lt;td&gt;Py: 200&lt;&#x2F;td&gt;&lt;td&gt;Py: 100REST: 70&lt;&#x2F;td&gt;&lt;td&gt;Py: 50&lt;&#x2F;td&gt;&lt;td&gt;Py: 50&lt;&#x2F;td&gt;&lt;td&gt;Py: 40&lt;&#x2F;td&gt;&lt;td&gt;Py: 240&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;&#x2F;tbody&gt;&lt;&#x2F;table&gt;
&lt;h3 id=&quot;ping-gu-zhi-biao-chart-with-upwards-trend&quot;&gt;评估指标 📈&lt;&#x2F;h3&gt;
&lt;p&gt;我们使用两种流行的方法来评估模型生成答案的准确性 :AST 评估和可执行评估。理想情况下应该使用执行评估，但在评估答案时，并非所有结果都容易执行 (例如 Java 函数)。因此我们使用 AST 作为执行评估的补充。&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;抽象语法树 (AST) 评估&lt;&#x2F;li&gt;
&lt;li&gt;可执行函数评估&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h4 id=&quot;chou-xiang-yu-fa-shu-ast-ping-gu-deciduous-tree&quot;&gt;抽象语法树 (AST) 评估 🌳&lt;&#x2F;h4&gt;
&lt;p&gt;对于&lt;strong&gt;简单函数评估&lt;&#x2F;strong&gt;，评估过程主要关注比较_单个模型输出函数_与其_函数文档_和_可能的答案_。下面的流程图展示了逐步评估过程。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;oss-ata.alibaba.com&#x2F;article&#x2F;2025&#x2F;01&#x2F;40db2ffc-94ab-4883-906b-1651fae5c132.jpeg&quot; alt=&quot;模型评估流程图&quot; &#x2F;&gt; &lt;em&gt;评估函数调用。使用函数描述和可能的答案来评估模型的输出函数。&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;h5 id=&quot;tong-guo-ast-jie-xi-han-shu&quot;&gt;通过 AST 解析函数&lt;&#x2F;h5&gt;
&lt;p&gt;评估过程从使用 AST 树解析函数调用开始。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;示例&lt;&#x2F;strong&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;plaintext&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-plaintext &quot;&gt;&lt;code class=&quot;language-plaintext&quot; data-lang=&quot;plaintext&quot;&gt;&lt;span&gt;calculate_triangle_area(base=10， height=5)
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;&lt;strong&gt;解析&lt;&#x2F;strong&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;plaintext&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-plaintext &quot;&gt;&lt;code class=&quot;language-plaintext&quot; data-lang=&quot;plaintext&quot;&gt;&lt;span&gt;Module(body=[
&lt;&#x2F;span&gt;&lt;span&gt;        Expr(value=List(elts=[
&lt;&#x2F;span&gt;&lt;span&gt;            Call(
&lt;&#x2F;span&gt;&lt;span&gt;                func=Name(id=&amp;#39;calculate_triangle_area&amp;#39;， ctx=Load())， 
&lt;&#x2F;span&gt;&lt;span&gt;                args=[]， 
&lt;&#x2F;span&gt;&lt;span&gt;                keywords=[
&lt;&#x2F;span&gt;&lt;span&gt;                    keyword(arg=&amp;#39;base&amp;#39;， value=Constant(value=10))， 
&lt;&#x2F;span&gt;&lt;span&gt;                    keyword(arg=&amp;#39;height&amp;#39;， value=Constant(value=5))
&lt;&#x2F;span&gt;&lt;span&gt;                ]
&lt;&#x2F;span&gt;&lt;span&gt;            )
&lt;&#x2F;span&gt;&lt;span&gt;        ]， ctx=Load()))
&lt;&#x2F;span&gt;&lt;span&gt;    ]， type_ignores=[])
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h5 id=&quot;han-shu-pi-pei&quot;&gt;函数匹配&lt;&#x2F;h5&gt;
&lt;p&gt;该过程首先提取函数名称，并验证其与可能答案中的函数名称是否一致。&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;在此，请注意函数名称可能包含&lt;code&gt;.&lt;&#x2F;code&gt;。 鉴于某些模型（例如 OpenAI 系列）可能不支持输入中的点&lt;code&gt;.&lt;&#x2F;code&gt;，我们在推断模型以生成函数输出时，将函数名称中的点替换为下划线&lt;code&gt;_&lt;&#x2F;code&gt;。 此替换在结果评估阶段重复进行。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h5 id=&quot;bi-xu-can-shu-pi-pei&quot;&gt;必需参数匹配&lt;&#x2F;h5&gt;
&lt;p&gt;然后，它从 AST 中提取参数，并检查每个参数是否能在可能的答案中找到并精确匹配。&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;该评估过程确保所有&lt;strong&gt;必需参数&lt;&#x2F;strong&gt;，即函数文档中通过 “required” 属性标识的参数，都存在于模型输出中。&lt;&#x2F;li&gt;
&lt;li&gt;它还确保只使用&lt;strong&gt;函数文档中存在的参数&lt;&#x2F;strong&gt;，标记出模型产生的幻觉输出。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h5 id=&quot;can-shu-lei-xing-he-zhi-pi-pei&quot;&gt;参数类型和值匹配&lt;&#x2F;h5&gt;
&lt;p&gt;评估过程对&lt;strong&gt;类型&lt;&#x2F;strong&gt;要求严格。以下是每种数据类型可接受的答案:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;对于 &lt;code&gt;bool&lt;&#x2F;code&gt; 类型:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;程序检查布尔值的直接匹配，不允许使用布尔值的字符串版本。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;对于 &lt;code&gt;integer&lt;&#x2F;code&gt;、&lt;code&gt;float&lt;&#x2F;code&gt; 类型:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;仅对 Python 测试&lt;&#x2F;strong&gt;，我们允许对期望 &lt;code&gt;float&lt;&#x2F;code&gt; 值的 Python 参数使用 &lt;code&gt;int&lt;&#x2F;code&gt; 值，以适应 Python 从 &lt;code&gt;int&lt;&#x2F;code&gt; 到 &lt;code&gt;float&lt;&#x2F;code&gt; 的自动转换特性。&lt;&#x2F;li&gt;
&lt;li&gt;对于非 Python 语言 (Java 和 JavaScript)，如果函数文档指定参数为 &lt;code&gt;float&lt;&#x2F;code&gt; 类型，那么模型输出中也必须是 &lt;code&gt;float&lt;&#x2F;code&gt;(如 &lt;code&gt;5.0&lt;&#x2F;code&gt;);使用 &lt;code&gt;int&lt;&#x2F;code&gt;(如 &lt;code&gt;5&lt;&#x2F;code&gt;)将是不正确的。&lt;&#x2F;li&gt;
&lt;li&gt;在任何语言中都不允许为 &lt;code&gt;int&lt;&#x2F;code&gt; 参数提供 &lt;code&gt;float&lt;&#x2F;code&gt; 值。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;对于 &lt;code&gt;List&lt;&#x2F;code&gt;、&lt;code&gt;Tuple&lt;&#x2F;code&gt; 类型:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;顺序很重要&lt;&#x2F;strong&gt;且元素&lt;strong&gt;必须完全匹配&lt;&#x2F;strong&gt;。例如，&lt;code&gt;[1，2，3]&lt;&#x2F;code&gt; 不等于 &lt;code&gt;[2，3，1]&lt;&#x2F;code&gt;。因此对于列表顺序无关紧要的问题，我们使用可能答案的排列组合来适应这种情况。&lt;&#x2F;li&gt;
&lt;li&gt;注意&lt;strong&gt;类型匹配&lt;&#x2F;strong&gt;对嵌套数据结构(&lt;code&gt;List&lt;&#x2F;code&gt; 或 &lt;code&gt;Tuple&lt;&#x2F;code&gt;)进行_递归_检查，外部类型和内部元素类型都必须符合指定要求。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;对于 &lt;code&gt;String&lt;&#x2F;code&gt; 类型:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;评估过程_不区分大小写_。&lt;&#x2F;li&gt;
&lt;li&gt;所有字符串在检查前都会被标准化。这适用于模型输出和可能的答案。
&lt;ul&gt;
&lt;li&gt;移除所有空白字符。&lt;&#x2F;li&gt;
&lt;li&gt;移除一部分标点符号 &lt;code&gt;，.&#x2F;-_*^&lt;&#x2F;code&gt; 以使评估更稳健和准确。&lt;&#x2F;li&gt;
&lt;li&gt;可能的日期格式 &lt;code&gt;[&amp;quot;20th June&amp;quot;， &amp;quot;2023-06-20&amp;quot;， &amp;quot;06&#x2F;20&#x2F;2023&amp;quot;， &amp;quot;Jun.20， 2023&amp;quot;]&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;可能的地点格式 &lt;code&gt;[&amp;quot;New York City&amp;quot;， &amp;quot;NYC&amp;quot;]&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;其他可能格式 &lt;code&gt;[&amp;quot;Manchester United&amp;quot;， &amp;quot;Man United&amp;quot;， &amp;quot;Man U&amp;quot;， &amp;quot;MUFC&amp;quot;]&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;对于 &lt;code&gt;Dict&lt;&#x2F;code&gt; 类型:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;评估重点关注_键的存在_以及与可能答案相关联的_值的准确性_。&lt;&#x2F;li&gt;
&lt;li&gt;由于字典本质上是_无序的_，因此不考虑字典内的顺序。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;对于&lt;code&gt;字典列表&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;虽然考虑字典的顺序 (因为它是&lt;code&gt;List&lt;&#x2F;code&gt;)，但不考虑每个字典内键值对的顺序。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;处理函数调用中的&lt;strong&gt;可选参数&lt;&#x2F;strong&gt;:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;对于真正&lt;strong&gt;可选&lt;&#x2F;strong&gt;的参数(换句话说，函数文档没有将该参数列为必需且可能答案包含空字符串 &lt;code&gt;&amp;quot;&amp;quot;&lt;&#x2F;code&gt;)，模型可以选择使用该参数的_默认值_，或者不提供值。两种方式都被认为是正确的。&lt;&#x2F;li&gt;
&lt;li&gt;对于函数文档中未列为_必需_且可能答案中不包含空字符串 &lt;code&gt;&amp;quot;&amp;quot;&lt;&#x2F;code&gt; 的参数，则该参数不是真正_可选_的。提示词必须暗示我们应该使用与默认值不同的值。在这种情况下，模型需要明确提供正确的值；使用默认值或不提供值将被标记为错误。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;当参数值是提示中提到的&lt;strong&gt;变量&lt;&#x2F;strong&gt;时，程序会特殊处理。例如，如果参数 &lt;code&gt;param1&lt;&#x2F;code&gt; 的类型是 &lt;code&gt;integer&lt;&#x2F;code&gt;，用户可以提供 &lt;code&gt;param1=value1&lt;&#x2F;code&gt;(其中 &lt;code&gt;value1&lt;&#x2F;code&gt; 是 &lt;code&gt;integer&lt;&#x2F;code&gt; 类型的具体值)，或 &lt;code&gt;param1=variable1&lt;&#x2F;code&gt;(其中 &lt;code&gt;variable1&lt;&#x2F;code&gt; 是保存 &lt;code&gt;integer&lt;&#x2F;code&gt; 值的变量)。因此评估在检查类型时会考虑这两种情况。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;对于 &lt;strong&gt;Java&lt;&#x2F;strong&gt; 和 &lt;strong&gt;JavaScript&lt;&#x2F;strong&gt; 测试类别，所有参数值 (在输入中) 都是字符串格式。评估程序将调用 &lt;code&gt;java_type_converter&lt;&#x2F;code&gt; 或 &lt;code&gt;js_type_converter&lt;&#x2F;code&gt; 辅助方法，将 &lt;strong&gt;Java&lt;&#x2F;strong&gt;&#x2F;&lt;strong&gt;JS&lt;&#x2F;strong&gt; 类型的字符串版本转换为相应的 Python 格式，因为我们使用 Python 数据类型进行检查。例如，&lt;strong&gt;Java&lt;&#x2F;strong&gt; 中的 &lt;code&gt;HashMap&lt;&#x2F;code&gt; 将被转换为 Python 中的字典。在此过程中，转换器还将对这些参数执行类型检查；例如，如果参数应该是 &lt;strong&gt;Java&lt;&#x2F;strong&gt; 中的 long 类型，转换器将确保字符串输入的末尾有 &lt;code&gt;&amp;quot;L&amp;quot;&lt;&#x2F;code&gt;(否则它将不是有效的 Java long 类型)。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;&lt;strong&gt;以下是一些可能答案的示例:&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;plaintext&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-plaintext &quot;&gt;&lt;code class=&quot;language-plaintext&quot; data-lang=&quot;plaintext&quot;&gt;&lt;span&gt;{&amp;quot;calculate_triangle_area&amp;quot;: {&amp;quot;base&amp;quot;: [10]， &amp;quot;height&amp;quot;: [5]， &amp;quot;unit&amp;quot;: [&amp;quot;units&amp;quot;， &amp;quot;unit&amp;quot;]}}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;pre data-lang=&quot;plaintext&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-plaintext &quot;&gt;&lt;code class=&quot;language-plaintext&quot; data-lang=&quot;plaintext&quot;&gt;&lt;span&gt;{&amp;quot;predict_house_price&amp;quot;: {&amp;quot;bedrooms&amp;quot;: [3]， &amp;quot;bathrooms&amp;quot;: [2]， &amp;quot;area&amp;quot;: [1800]， &amp;quot;location&amp;quot;: [&amp;quot;San Francisco&amp;quot;， &amp;quot;San Francisco， CA&amp;quot;]}}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h5 id=&quot;duo-zhong-bing-xing-bing-xing-duo-zhong-han-shu-de-ast-ping-gu&quot;&gt;多重&#x2F;并行&#x2F;并行多重函数的 AST 评估&lt;&#x2F;h5&gt;
&lt;p&gt;&lt;strong&gt;多重、并行或并行多重函数的 AST 评估过程&lt;&#x2F;strong&gt;扩展了简单函数评估的思路，以支持多个模型输出和可能的答案。&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;评估过程首先将每个可能的答案与其函数文档关联。然后遍历模型输出，对每个函数调用&lt;strong&gt;简单函数评估&lt;&#x2F;strong&gt;(该评估接收一个_模型输出_、&lt;em&gt;一个可能的答案_和一个_函数文档&lt;&#x2F;em&gt;)。
&lt;ul&gt;
&lt;li&gt;不要求模型输出相对于可能答案的顺序。一个模型输出可以与任何可能的答案匹配。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;评估采用_全有或全无_的方法。如果任何给定的可能答案无法在所有模型输出中找到匹配，则导致_评估失败_。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h4 id=&quot;ke-zhi-xing-han-shu-ping-gu-gear&quot;&gt;可执行函数评估 ⚙️&lt;&#x2F;h4&gt;
&lt;p&gt;在&lt;code&gt;可执行&lt;&#x2F;code&gt;测试类别中，我们执行生成的 API 调用以检查响应的正确性。由于&lt;code&gt;非 REST&lt;&#x2F;code&gt;和 &lt;code&gt;REST&lt;&#x2F;code&gt; 测试的特点不同，评估过程也有所不同:&lt;&#x2F;p&gt;
&lt;h5 id=&quot;ke-zhi-xing-han-shu-fei-rest-ping-gu&quot;&gt;可执行函数(&lt;code&gt;非 REST&lt;&#x2F;code&gt;)评估:&lt;&#x2F;h5&gt;
&lt;ul&gt;
&lt;li&gt;执行涉及运行指定的函数并检查其输出。&lt;&#x2F;li&gt;
&lt;li&gt;评估标准(根据可执行函数示例，必须满足以下任一条件):
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;精确匹配&lt;&#x2F;strong&gt;: 输出必须与预期结果完全匹配。&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;实时匹配&lt;&#x2F;strong&gt;: 这是一种较为宽松的精确匹配形式，仅适用于数值执行结果，其中执行结果必须在预期结果的某个百分比阈值(20%)内，以适应 API 响应的实时更新。&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;结构匹配&lt;&#x2F;strong&gt;: 输出必须匹配预期的数据类型。例如，如果预期类型是 &lt;code&gt;list&lt;&#x2F;code&gt;，则&lt;code&gt;[1， 2， 3]&lt;&#x2F;code&gt;和&lt;code&gt;[1.5， 2.4， 6]&lt;&#x2F;code&gt;都可以接受。此外，以下类型有一些特殊要求:
&lt;ul&gt;
&lt;li&gt;对于 &lt;code&gt;List&lt;&#x2F;code&gt;，长度必须与预期长度匹配。不检查每个元素的类型。&lt;&#x2F;li&gt;
&lt;li&gt;对于 &lt;code&gt;Dict&lt;&#x2F;code&gt;，键必须与预期输出中存在的键匹配。这意味着不能有多余的键也不能缺少键。不检查每个值的类型。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h5 id=&quot;ke-zhi-xing-han-shu-rest-ping-gu&quot;&gt;可执行函数 (&lt;code&gt;REST&lt;&#x2F;code&gt;) 评估:&lt;&#x2F;h5&gt;
&lt;ul&gt;
&lt;li&gt;这些测试涉及执行 API 调用并评估:
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;有效执行&lt;&#x2F;strong&gt;: 评估 API 调用执行的成功性。&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;响应类型准确性&lt;&#x2F;strong&gt;: 确保 API 响应匹配预期结构 (例如，&lt;code&gt;JSON 对象列表&lt;&#x2F;code&gt;)。&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;JSON 键一致性&lt;&#x2F;strong&gt;: 检查生成的响应和预期响应之间的 &lt;em&gt;JSON 键集&lt;&#x2F;em&gt; 是否一致。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;初始收集并以 JSON 格式存储了 &lt;code&gt;REST&lt;&#x2F;code&gt; 响应的基准数据，用于比较。&lt;&#x2F;li&gt;
&lt;li&gt;考虑到 &lt;code&gt;REST&lt;&#x2F;code&gt; 响应的_可变性质_(例如，变化的天气数据)，可执行评估侧重于_结构不变性_和_实时执行成功_，而不是静态值。
&lt;ul&gt;
&lt;li&gt;特别是，可执行评估验证响应类型是否与基准数据匹配 (例如，期望得到 JSON 对象列表)，并检查元素数量和 JSON 键集的一致性。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;&lt;strong&gt;声明&lt;&#x2F;strong&gt;: 考虑到 &lt;code&gt;REST&lt;&#x2F;code&gt;API 响应结构可能会被其开发者更新，评估方法包含了一个可选的 API 健康检查，以确保在运行任何可执行类别测试之前，评估过程中涉及的所有 API 都按预期工作。&lt;code&gt;REST&lt;&#x2F;code&gt; 类别的基准数据也会定期审查和更新，以确保评估保持准确和相关性。&lt;&#x2F;p&gt;
&lt;h5 id=&quot;duo-zhong-bing-xing-bing-xing-duo-zhong-ke-zhi-xing-han-shu-ping-gu&quot;&gt;多重&#x2F;并行&#x2F;并行多重可执行函数评估&lt;&#x2F;h5&gt;
&lt;p&gt;&lt;strong&gt;多重、并行或并行多重可执行函数评估过程&lt;&#x2F;strong&gt;扩展了简单可执行函数评估的思路。&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;评估过程首先执行每个模型生成的函数调用。然后，它将实时执行的输出与基准执行输出进行比较，并对每对输出调用简单可执行函数评估程序。
&lt;ul&gt;
&lt;li&gt;不要求模型执行输出相对于基准执行输出的顺序。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;评估采用_全有或全无_的方法。如果任何给定的基准执行输出及其相应的评估标准无法在所有模型执行输出中找到匹配，则导致_评估失败_。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h3 id=&quot;cheng-ben-he-yan-chi&quot;&gt;成本和延迟&lt;&#x2F;h3&gt;
&lt;p&gt;在我们最近的更新中，我们也特别关注了&lt;strong&gt;成本&lt;&#x2F;strong&gt;和&lt;strong&gt;延迟&lt;&#x2F;strong&gt;。&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;对于来自 OpenAI、Mistral、Google、Anthropic 等服务提供商的模型:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;延迟&lt;&#x2F;strong&gt;: 我们通过计时每个端点请求来测量延迟，不包括函数文档预处理时间。&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;成本&lt;&#x2F;strong&gt;: 我们遵循公式计算每 1000 次函数调用的成本。&lt;img src=&quot;https:&#x2F;&#x2F;oss-ata.alibaba.com&#x2F;article&#x2F;2025&#x2F;01&#x2F;4d988535-0d9b-404c-bb6a-52155284ad88.jpg&quot; alt=&quot;img&quot; &#x2F;&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;对于我们使用本地托管评估的模型(包括 Deepseek、Gemma 等):&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;延迟&lt;&#x2F;strong&gt;: 我们使用 8 个 V100 GPU 通过 vLLM 服务模型时计算得出数据。由于我们对模型进行了批处理和评估，我们通过将总时间除以评估数据集条目数来得出延迟。&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;成本&lt;&#x2F;strong&gt;: 由于开源模型没有价格标签，我们通过以下方式估算成本:&lt;img src=&quot;https:&#x2F;&#x2F;oss-ata.alibaba.com&#x2F;article&#x2F;2025&#x2F;01&#x2F;23e7766d-112d-41d8-af34-70696ce19a77.jpg&quot; alt=&quot;img&quot; &#x2F;&gt;我们在成本计算中使用了 Azure ND40rs-v2 实例(8X V100 GPU)2024 年 4 月的按需付费定价。这并不精确，因为价格经常变动。我们会尽最大努力每天或至少每周更新这些数据。尽管如此，这应该能让人了解成本的大致范围，并帮助理解在所有条件相同的情况下的相对排序。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;对于 firefunctions-v1、Nexusflow-Raven-v2 和 Meetkai-Functionary，我们在他们的服务免费期间使用他们的端点，所以我们没有包含这些模型的成本。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;em&gt;这一特定见解将帮助个人或企业根据需求和预算决定采用哪个模型。&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;h3 id=&quot;he-shi-shi-yong-han-shu-diao-yong-gong-ju-diao-yong-he-shi-shi-yong-ti-shi&quot;&gt;何时使用函数调用 (工具调用)，何时使用提示? 🖊️&lt;&#x2F;h3&gt;
&lt;p&gt;下面的模型卡片展示了我们评估的不同模型支持的见解和函数调用功能。&lt;&#x2F;p&gt;
&lt;p&gt;从上面的模型卡片中，我们强调我们的评估同时涉及函数调用和非函数调用模型。对于函数调用模型，由于它们是专门设计用来生成函数调用的，我们没有提供任何系统提示，而是打开函数调用模式并将函数定义放在应该在的位置。对于非函数调用模型，我们只是用系统消息提示它们。我们提供了所有用于评估专有和开源模型的提示。&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;对于所有函数调用模型，我们没有提供任何系统提示，而是打开函数调用模式并将函数定义放在应该在的位置。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;对于聊天模型，我们明确提供了一个&lt;strong&gt;系统消息&lt;&#x2F;strong&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;plaintext&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-plaintext &quot;&gt;&lt;code class=&quot;language-plaintext&quot; data-lang=&quot;plaintext&quot;&gt;&lt;span&gt;SYSTEM_PROMPT_FOR_CHAT_MODEL = &amp;quot;&amp;quot;&amp;quot;
&lt;&#x2F;span&gt;&lt;span&gt;你是一个编写函数的专家。你会收到一个问题和一组可能的函数。
&lt;&#x2F;span&gt;&lt;span&gt;根据问题，你需要进行一次或多次函数&#x2F;工具调用来实现目的。
&lt;&#x2F;span&gt;&lt;span&gt;如果没有可以使用的函数，请指出。如果给定的问题缺少函数所需的参数，也请指出。你应该只在工具调用部分返回函数调用。
&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;&amp;quot;&amp;quot;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;pre data-lang=&quot;plaintext&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-plaintext &quot;&gt;&lt;code class=&quot;language-plaintext&quot; data-lang=&quot;plaintext&quot;&gt;&lt;span&gt;USER_MESSAGE_FOR_CHAT_MODEL = &amp;quot;问题:{user_prompt}\n这里是你可以调用的 JSON 格式函数列表:\n{functions}。如果你决定返回函数调用，不能包含任何其他文本。&amp;quot;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;h4 id=&quot;chang-jian-cuo-wu&quot;&gt;常见错误&lt;&#x2F;h4&gt;
&lt;p&gt;通过我们的基准测试 BFCL，我们能够识别出 LLM 在生成函数调用时的一些常见错误。这些错误很有趣，因为它们帮助我们理解当前模型的局限性，并为如何改进它们提供见解。&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;GPT 的_函数文档难以格式化_，并且它们的_类型在现实场景中过于严格_。&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;plaintext&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-plaintext &quot;&gt;&lt;code class=&quot;language-plaintext&quot; data-lang=&quot;plaintext&quot;&gt;&lt;span&gt;&amp;quot;Function&amp;quot;: 
&lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &amp;quot;name&amp;quot;: &amp;quot;calculate_binomial_probability&amp;quot;,
&lt;&#x2F;span&gt;&lt;span&gt;    ...
&lt;&#x2F;span&gt;&lt;span&gt;    &amp;quot;parameters&amp;quot;: 
&lt;&#x2F;span&gt;&lt;span&gt;    {
&lt;&#x2F;span&gt;&lt;span&gt;        &amp;quot;type&amp;quot;: &amp;quot;object&amp;quot;, 
&lt;&#x2F;span&gt;&lt;span&gt;        &amp;quot;properties&amp;quot;: 
&lt;&#x2F;span&gt;&lt;span&gt;        {
&lt;&#x2F;span&gt;&lt;span&gt;            &amp;quot;number_of_trials&amp;quot;: 
&lt;&#x2F;span&gt;&lt;span&gt;            {
&lt;&#x2F;span&gt;&lt;span&gt;                &amp;quot;type&amp;quot;: &amp;quot;integer&amp;quot;, 
&lt;&#x2F;span&gt;&lt;span&gt;                &amp;quot;description&amp;quot;: &amp;quot;The total number of trials.&amp;quot;
&lt;&#x2F;span&gt;&lt;span&gt;            },
&lt;&#x2F;span&gt;&lt;span&gt;            &amp;quot;number_of_successes&amp;quot;: 
&lt;&#x2F;span&gt;&lt;span&gt;            {
&lt;&#x2F;span&gt;&lt;span&gt;                &amp;quot;type&amp;quot;: &amp;quot;integer&amp;quot;, 
&lt;&#x2F;span&gt;&lt;span&gt;                &amp;quot;description&amp;quot;: &amp;quot;The desired number of successful outcomes.&amp;quot;
&lt;&#x2F;span&gt;&lt;span&gt;            },
&lt;&#x2F;span&gt;&lt;span&gt;            &amp;quot;probability_of_success&amp;quot;: 
&lt;&#x2F;span&gt;&lt;span&gt;            {
&lt;&#x2F;span&gt;&lt;span&gt;                &amp;quot;type&amp;quot;: &amp;quot;float&amp;quot;, 
&lt;&#x2F;span&gt;&lt;span&gt;                The probability of a successful outcome on any given trial.&amp;quot;, 
&lt;&#x2F;span&gt;&lt;span&gt;                &amp;quot;default&amp;quot;: 0.5
&lt;&#x2F;span&gt;&lt;span&gt;            }
&lt;&#x2F;span&gt;&lt;span&gt;            ...
&lt;&#x2F;span&gt;&lt;span&gt;        }
&lt;&#x2F;span&gt;&lt;span&gt;        &amp;quot;required&amp;quot;: [&amp;quot;number_of_trials&amp;quot;, &amp;quot;number_of_successes&amp;quot;]
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;在这种情况下，我们需要手动将 float 转换为 number 以使函数与 OpenAI 兼容。此外，在精度和类型一致性方面，&lt;code&gt;number&lt;&#x2F;code&gt; 相比 &lt;code&gt;float&lt;&#x2F;code&gt; 传递的信息更少。&lt;&#x2F;p&gt;
&lt;p&gt;在 Gorilla OpenFunctions-v2 中，我们通过不限制参数的类型来提高函数文档的灵活性。换句话说，用户可以使用 &lt;code&gt;Tuple&lt;&#x2F;code&gt;、&lt;code&gt;Float&lt;&#x2F;code&gt;，甚至像 Java 中的 &lt;code&gt;Hashmap&lt;&#x2F;code&gt; 和 &lt;code&gt;Linked List&lt;&#x2F;code&gt; 这样的特定语言类型！&lt;&#x2F;p&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;
&lt;p&gt;GPT 在_参数不能直接从用户问题中获得_而需要进行一些隐式转换的场景中表现不佳。以下是一个例子:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;plaintext&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-plaintext &quot;&gt;&lt;code class=&quot;language-plaintext&quot; data-lang=&quot;plaintext&quot;&gt;&lt;span&gt;&amp;quot;Function&amp;quot;: 
&lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &amp;quot;name&amp;quot;: &amp;quot;finance.predict_future_value&amp;quot;,
&lt;&#x2F;span&gt;&lt;span&gt;    ...
&lt;&#x2F;span&gt;&lt;span&gt;    &amp;quot;parameters&amp;quot;: 
&lt;&#x2F;span&gt;&lt;span&gt;    {
&lt;&#x2F;span&gt;&lt;span&gt;        &amp;quot;type&amp;quot;: &amp;quot;object&amp;quot;, 
&lt;&#x2F;span&gt;&lt;span&gt;        &amp;quot;properties&amp;quot;: 
&lt;&#x2F;span&gt;&lt;span&gt;        {
&lt;&#x2F;span&gt;&lt;span&gt;            &amp;quot;present_value&amp;quot;: 
&lt;&#x2F;span&gt;&lt;span&gt;            {
&lt;&#x2F;span&gt;&lt;span&gt;                &amp;quot;type&amp;quot;: &amp;quot;number&amp;quot;, 
&lt;&#x2F;span&gt;&lt;span&gt;                &amp;quot;description&amp;quot;: &amp;quot;The present value of the investment.&amp;quot;
&lt;&#x2F;span&gt;&lt;span&gt;            },
&lt;&#x2F;span&gt;&lt;span&gt;            
&lt;&#x2F;span&gt;&lt;span&gt;            &amp;quot;annual_interest_rate&amp;quot;: 
&lt;&#x2F;span&gt;&lt;span&gt;            {
&lt;&#x2F;span&gt;&lt;span&gt;                &amp;quot;type&amp;quot;: &amp;quot;number&amp;quot;, 
&lt;&#x2F;span&gt;&lt;span&gt;                &amp;quot;description&amp;quot;: &amp;quot;The annual interest rate of the investment.&amp;quot;
&lt;&#x2F;span&gt;&lt;span&gt;            },
&lt;&#x2F;span&gt;&lt;span&gt;            
&lt;&#x2F;span&gt;&lt;span&gt;            &amp;quot;compounding_periods_per_year&amp;quot;: 
&lt;&#x2F;span&gt;&lt;span&gt;            {
&lt;&#x2F;span&gt;&lt;span&gt;                &amp;quot;type&amp;quot;: &amp;quot;integer&amp;quot;, 
&lt;&#x2F;span&gt;&lt;span&gt;                &amp;quot;description&amp;quot;: &amp;quot;The number of times that interest is compounded per year.&amp;quot;, 
&lt;&#x2F;span&gt;&lt;span&gt;            },
&lt;&#x2F;span&gt;&lt;span&gt;            &amp;quot;time_years&amp;quot;: 
&lt;&#x2F;span&gt;&lt;span&gt;            {
&lt;&#x2F;span&gt;&lt;span&gt;                &amp;quot;type&amp;quot;: &amp;quot;integer&amp;quot;, 
&lt;&#x2F;span&gt;&lt;span&gt;                &amp;quot;description&amp;quot;: &amp;quot;The investment horizon in years.&amp;quot;
&lt;&#x2F;span&gt;&lt;span&gt;            }
&lt;&#x2F;span&gt;&lt;span&gt;            ...
&lt;&#x2F;span&gt;&lt;span&gt;        }
&lt;&#x2F;span&gt;&lt;span&gt;        &amp;quot;required&amp;quot;: [&amp;quot;present_value&amp;quot;, &amp;quot;annual_interest_rate&amp;quot;, &amp;quot;time_years&amp;quot;]
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;&lt;strong&gt;问题&lt;&#x2F;strong&gt;: 预测一笔 5000 美元的投资，年利率为 5%，按月复利计算，3 年后的未来价值。&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;plaintext&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-plaintext &quot;&gt;&lt;code class=&quot;language-plaintext&quot; data-lang=&quot;plaintext&quot;&gt;&lt;span&gt;GPT-4 output:
&lt;&#x2F;span&gt;&lt;span&gt;[{
&lt;&#x2F;span&gt;&lt;span&gt;    &amp;quot;name&amp;quot;: &amp;quot;finance.predict_future_value&amp;quot;,
&lt;&#x2F;span&gt;&lt;span&gt;    &amp;quot;parameters&amp;quot;: 
&lt;&#x2F;span&gt;&lt;span&gt;    {
&lt;&#x2F;span&gt;&lt;span&gt;        &amp;quot;present_value&amp;quot;: 5000,
&lt;&#x2F;span&gt;&lt;span&gt;        &amp;quot;annual_interest_rate&amp;quot;: 5,
&lt;&#x2F;span&gt;&lt;span&gt;        &amp;quot;compounding_periods_per_year&amp;quot;: 12,
&lt;&#x2F;span&gt;&lt;span&gt;        &amp;quot;time_years&amp;quot;: 3
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}]
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;pre data-lang=&quot;plaintext&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-plaintext &quot;&gt;&lt;code class=&quot;language-plaintext&quot; data-lang=&quot;plaintext&quot;&gt;&lt;span&gt;Gorilla-openfunctions-v2 output:
&lt;&#x2F;span&gt;&lt;span&gt;[{
&lt;&#x2F;span&gt;&lt;span&gt;    &amp;quot;name&amp;quot;: &amp;quot;finance.predict_future_value&amp;quot;,
&lt;&#x2F;span&gt;&lt;span&gt;    &amp;quot;parameters&amp;quot;: 
&lt;&#x2F;span&gt;&lt;span&gt;    {
&lt;&#x2F;span&gt;&lt;span&gt;        &amp;quot;present_value&amp;quot;: 5000,
&lt;&#x2F;span&gt;&lt;span&gt;        &amp;quot;annual_interest_rate&amp;quot;: 0.05,
&lt;&#x2F;span&gt;&lt;span&gt;        &amp;quot;compounding_periods_per_year&amp;quot;: 12,
&lt;&#x2F;span&gt;&lt;span&gt;        &amp;quot;time_years&amp;quot;: 3
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}]
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;ol start=&quot;3&quot;&gt;
&lt;li&gt;
&lt;p&gt;聊天模型倾向于生成_格式错误的函数调用_，其中参数可以提取但无法执行&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;示例&lt;&#x2F;strong&gt;: &lt;code&gt;mistral-medium&lt;&#x2F;code&gt; 生成的结果如 &lt;code&gt;solve\\_quadratic\\_equation(a=2， b=6， c=5)&lt;&#x2F;code&gt;。而使用 gorilla-openfunctions-v2，我们可以直接输出 &lt;code&gt;solve_quadratic_equation(a=3， b=2， c=1)&lt;&#x2F;code&gt;，这在收到结果时是可执行的。&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;REST API &lt;em&gt;缺少 URL&lt;&#x2F;em&gt;:&lt;&#x2F;p&gt;
&lt;p&gt;由于 GPT-4 在获取天气数据的 REST API 请求中缺少必需的 URL 而产生差异。虽然 GPT-4 输出省略了必要的 URL，但 Gorilla Openfunctions-v2 模型成功包含了正确的 API 端点，使其能够成功执行并检索指定坐标和预报期的天气信息。&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;plaintext&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-plaintext &quot;&gt;&lt;code class=&quot;language-plaintext&quot; data-lang=&quot;plaintext&quot;&gt;&lt;span&gt;&amp;quot;User&amp;quot;: &amp;quot;Can you fetch me the weather data for the coordinates 
&lt;&#x2F;span&gt;&lt;span&gt;37.8651 N, 119.5383 W, including the hourly forecast for temperature, 
&lt;&#x2F;span&gt;&lt;span&gt;wind speed, and precipitation for the next 10 days?&amp;quot;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;Function&amp;quot;: 
&lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &amp;quot;name&amp;quot;: &amp;quot;requests.get&amp;quot;,
&lt;&#x2F;span&gt;&lt;span&gt;    ...
&lt;&#x2F;span&gt;&lt;span&gt;    &amp;quot;parameters&amp;quot;: 
&lt;&#x2F;span&gt;&lt;span&gt;    {
&lt;&#x2F;span&gt;&lt;span&gt;        &amp;quot;type&amp;quot;: &amp;quot;object&amp;quot;, 
&lt;&#x2F;span&gt;&lt;span&gt;        &amp;quot;properties&amp;quot;: 
&lt;&#x2F;span&gt;&lt;span&gt;        {
&lt;&#x2F;span&gt;&lt;span&gt;            &amp;quot;url&amp;quot;: 
&lt;&#x2F;span&gt;&lt;span&gt;            {
&lt;&#x2F;span&gt;&lt;span&gt;                &amp;quot;type&amp;quot;: &amp;quot;string&amp;quot;, 
&lt;&#x2F;span&gt;&lt;span&gt;                &amp;quot;description&amp;quot;: &amp;quot;The API endpoint for fetching
&lt;&#x2F;span&gt;&lt;span&gt;                weather data from the Open-Meteo API for the 
&lt;&#x2F;span&gt;&lt;span&gt;                given latitude and longitude, default 
&lt;&#x2F;span&gt;&lt;span&gt;                https:&#x2F;&#x2F;api.open-meteo.com&#x2F;v1&#x2F;forecast&amp;quot;
&lt;&#x2F;span&gt;&lt;span&gt;            }
&lt;&#x2F;span&gt;&lt;span&gt;            ...
&lt;&#x2F;span&gt;&lt;span&gt;        }
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;pre data-lang=&quot;plaintext&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-plaintext &quot;&gt;&lt;code class=&quot;language-plaintext&quot; data-lang=&quot;plaintext&quot;&gt;&lt;span&gt;GPT-4 output:
&lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &amp;quot;name&amp;quot;: &amp;quot;requests.get&amp;quot;,
&lt;&#x2F;span&gt;&lt;span&gt;    &amp;quot;parameters&amp;quot;: {
&lt;&#x2F;span&gt;&lt;span&gt;        &amp;quot;url&amp;quot;: &amp;quot;Missing&amp;quot;,
&lt;&#x2F;span&gt;&lt;span&gt;        &amp;quot;params&amp;quot;: 
&lt;&#x2F;span&gt;&lt;span&gt;        {
&lt;&#x2F;span&gt;&lt;span&gt;            &amp;quot;latitude&amp;quot;: &amp;quot;37.8651&amp;quot;,
&lt;&#x2F;span&gt;&lt;span&gt;            &amp;quot;longitude&amp;quot;: &amp;quot;-119.5383&amp;quot;,
&lt;&#x2F;span&gt;&lt;span&gt;            &amp;quot;forecast_days&amp;quot;: 10
&lt;&#x2F;span&gt;&lt;span&gt;        },
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;pre data-lang=&quot;plaintext&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-plaintext &quot;&gt;&lt;code class=&quot;language-plaintext&quot; data-lang=&quot;plaintext&quot;&gt;&lt;span&gt;Gorilla-Openfunctions-v2 output:
&lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &amp;quot;name&amp;quot;: &amp;quot;requests.get&amp;quot;,
&lt;&#x2F;span&gt;&lt;span&gt;    &amp;quot;parameters&amp;quot;: {
&lt;&#x2F;span&gt;&lt;span&gt;        &amp;quot;url&amp;quot;: &amp;quot;https:&#x2F;&#x2F;api.open-meteo.com&#x2F;v1&#x2F;forecast&amp;quot;,
&lt;&#x2F;span&gt;&lt;span&gt;        &amp;quot;params&amp;quot;: 
&lt;&#x2F;span&gt;&lt;span&gt;        {
&lt;&#x2F;span&gt;&lt;span&gt;            &amp;quot;latitude&amp;quot;: &amp;quot;37.8651&amp;quot;,
&lt;&#x2F;span&gt;&lt;span&gt;            &amp;quot;longitude&amp;quot;: &amp;quot;-119.5383&amp;quot;,
&lt;&#x2F;span&gt;&lt;span&gt;            &amp;quot;forecast_days&amp;quot;: 10
&lt;&#x2F;span&gt;&lt;span&gt;        },
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;h4 id=&quot;jie-lun&quot;&gt;结论&lt;&#x2F;h4&gt;
&lt;p&gt;我们通过 Berkeley 函数调用排行榜对 LLM 的函数调用能力提供了全面和系统的评估。这里的研究表明，就简单的函数调用而言 (不涉及复杂规划和链式函数调用)，微调开源模型可以达到与专有模型相当的效果。此外，我们提供了 Gorilla Open Functions v2，这是一个开源模型，可以帮助用户构建具有函数调用功能并能与 JSON 兼容输出交互的 AI 应用程序。&lt;&#x2F;p&gt;
&lt;p&gt;我们希望你喜欢这篇博文。我们很乐意在 &lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;discord.gg&#x2F;grXXvj9Whz&quot;&gt;Discord&lt;&#x2F;a&gt;、&lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;twitter.com&#x2F;shishirpatil_&#x2F;status&#x2F;1661780076277678082&quot;&gt;Twitter (#GorillaLLM)&lt;&#x2F;a&gt; 和 &lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;ShishirPatil&#x2F;gorilla&#x2F;&quot;&gt;GitHub&lt;&#x2F;a&gt; 上听取你的意见。&lt;&#x2F;p&gt;
&lt;h4 id=&quot;yin-yong&quot;&gt;引用&lt;&#x2F;h4&gt;
&lt;p&gt;如果你想引用 Gorilla:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;bibtex&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-bibtex &quot;&gt;&lt;code class=&quot;language-bibtex&quot; data-lang=&quot;bibtex&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;@inproceedings&lt;&#x2F;span&gt;&lt;span&gt;{berkeley-function-calling-leaderboard，
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;title&lt;&#x2F;span&gt;&lt;span&gt;={&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;Berkeley Function Calling Leaderboard&lt;&#x2F;span&gt;&lt;span&gt;}，
&lt;&#x2F;span&gt;&lt;span&gt;  author={&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;Fanjia Yan and Huanzhi Mao and Charlie Cheng-Jie Ji and Tianjun Zhang and Shishir G. Patil and Ion Stoica and Joseph E. Gonzalez&lt;&#x2F;span&gt;&lt;span&gt;}，
&lt;&#x2F;span&gt;&lt;span&gt;  year={&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;2024&lt;&#x2F;span&gt;&lt;span&gt;}，
&lt;&#x2F;span&gt;&lt;span&gt;  howpublished={&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;\\url{https:&#x2F;&#x2F;gorilla.cs.berkeley.edu&#x2F;blogs&#x2F;8_berkeley_function_calling_leaderboard.html}&lt;&#x2F;span&gt;&lt;span&gt;}，
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
</content>
        
    </entry>
    <entry xml:lang="zh">
        <title>Agent Arena：一个用于评估和比较大型语言模型Agent的平台</title>
        <published>2025-01-16T00:00:00+00:00</published>
        <updated>2025-01-16T00:00:00+00:00</updated>
        <author>
          <name>Unknown</name>
        </author>
        <link rel="alternate" href="https://linq.github.io/posts/agent-arena/" type="text/html"/>
        <id>https://linq.github.io/posts/agent-arena/</id>
        
        <content type="html">&lt;h2 id=&quot;jian-jie&quot;&gt;简介&lt;&#x2F;h2&gt;
&lt;blockquote&gt;
&lt;p&gt;这篇文章介绍了 Agent Arena 一个用于评估和比较 LLM Agent的交互式平台。该平台允许用户根据自己的需求测试不同的Agent组合(包括模型、框架和工具)，并通过投票系统对其性能进行评估。文章详细讨论了平台的核心组件，包括路由系统、评估机制、排行榜等，并通过多个实际用例展示了Agent在教育、金融、医疗等领域的应用潜力。此外，文章还介绍了平台的未来发展路线图，展望了 LLM Agent评估的发展方向。&lt;&#x2F;p&gt;
&lt;p&gt;原文地址：https:&#x2F;&#x2F;gorilla.cs.berkeley.edu&#x2F;blogs&#x2F;14_agent_arena.html&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;随着大语言模型(LLM)Agent的日益普及，我们需要一个统一和系统的方法来评估Agent。&lt;&#x2F;p&gt;
&lt;p&gt;LLMAgent正被应用于各种用例中，从搜索和代码生成到金融和研究等复杂任务。我们认为LLMAgent由三个组件构成 - LLM模型(如GPT-4、Claude、Llama 3.1)、框架(LangChain、LlamaIndex、CrewAI等)和工具(代码解释器、Brave Search或Yahoo Finance等API)。例如，一个用于总结财报的Agent可能由GPT-4模型驱动，使用PDFReader工具来读取财报PDF，并由langchain来编排! Agent-arena捕获并对Agent作为整体以及三个子组件的用户偏好进行排名，为模型开发者、工具开发者以及更重要的是LLMAgent用户提供见解!&lt;&#x2F;p&gt;
&lt;p&gt;Agent在模型和框架评估方面有许多细微差别。例如，假设我想构建一个检索本周表现最佳股票的金融助手。&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;❓&lt;strong&gt;我应该使用什么模型?&lt;&#x2F;strong&gt; 一个模型可能接受过更多金融数据的训练💸，而另一个可能在推理♟️和计算➗方面表现出色。&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;❓&lt;strong&gt;框架呢?&lt;&#x2F;strong&gt; 一个平台可能有更多的API集成，但另一个可能在互联网索引方面做得更好。&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;❓&lt;strong&gt;我应该使用什么工具?&lt;&#x2F;strong&gt; 对于这个特定用例，我是需要返回股票价格📈的工具还是能返回市场新闻📰的API。&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;正如这个例子所示，在设计Agent工作流程时需要考虑很多因素 - 而这仅仅是金融领域潜在数十个用例中的一个。不同的用例需要不同的模型、工具和框架组合。&lt;&#x2F;p&gt;
&lt;p&gt;我们很高兴发布 &lt;strong&gt;🤖 Agent Arena&lt;&#x2F;strong&gt;，这是一个交互式沙盒，用户可以根据自己的需求比较、可视化和评价Agent工作流程。Agent Arena允许用户从任务、LLM提供商、框架、工具等组合中进行选择，并对其性能进行投票。我们使用户能够以结构化和系统化的方式看到不同Agent之间的表现对比。通过这样做，我们相信用户可以对他们的&lt;em&gt;Agent技术栈&lt;&#x2F;em&gt;做出更明智的决定。此外，通过Agent Arena，我们希望展示Agent的不足之处和令人印象深刻的进展!&lt;&#x2F;p&gt;
&lt;p&gt;Agent Arena还包括按领域分组的LLM模型、框架和工具的实时排行榜和排名。此外，我们认为这些排名可以帮助指导模型、工具和框架开发者，帮助他们了解他们在各种用例中的表现以及如何改进。同时认识到基于用户投票的选举会受到选择偏差的影响，作为一个新功能，Agent Arena还包括一个Prompt Hub，您可以在那里订阅特定的提示专家并查看他们对各种任务的个人意见。&lt;strong&gt;您&lt;&#x2F;strong&gt;也可以发布您的提示集!&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;快速链接:&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Agent Arena:&lt;&#x2F;strong&gt; &lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.agent-arena.com&#x2F;&quot;&gt;Agent-Arena&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;排行榜:&lt;&#x2F;strong&gt; &lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.agent-arena.com&#x2F;leaderboard&quot;&gt;Agent 排行榜&lt;&#x2F;a&gt; &lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;用户提示:&lt;&#x2F;strong&gt; &lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.agent-arena.com&#x2F;users&quot;&gt;提示中心&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;Agent对战数据:&lt;&#x2F;strong&gt; &lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;ShishirPatil&#x2F;gorilla&#x2F;blob&#x2F;main&#x2F;agent-arena&#x2F;evalutation&#x2F;agent_ratings_V0.json&quot;&gt;Agent对战数据&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;shi-yao-shi-agent&quot;&gt;🦜 什么是Agent?&lt;&#x2F;h2&gt;
&lt;p&gt;在 Agent Arena 中，Agent被定义为能够利用各种子组件执行复杂任务的实体。我们将每个Agent定义为由三个组件组成 - LLM模型、工具和框架。我们考虑的Agent来自成熟的框架，如 LangChain、LlamaIndex、CrewAI、Composio，以及 OpenAI 和 Anthropic 提供的助手。这些Agent都可能展现出思维链推理、工具使用和函数调用等特性，使它们能够高效执行复杂任务。对于平台来说，我们使用支持函数调用和工具使用的模型，这些是 LLM Agent的关键方面。&lt;&#x2F;p&gt;
&lt;p&gt;例如，LangChain 和 LlamaIndex Agent配备了特定的工具包，可以增强其解决问题的能力。OpenAI 的助手，如代码解释器和文件处理模型，由于其展示出解释代码、处理文件和调用外部函数的能力，也可以称为Agent。Anthropic 的Agent与外部工具集成，其他框架的类似示例进一步增强了它们在特定任务中的实用性。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;agent-arena-ping-tai&quot;&gt;Agent Arena 平台&lt;&#x2F;h2&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;oss-ata.alibaba.com&#x2F;article&#x2F;2025&#x2F;01&#x2F;fc4ac1e9-d733-41a9-8e30-1c4a93e95dd7.png&quot; alt=&quot;执行流程&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;em&gt;基于用户目标、模型、框架和执行时间、ELO等性能指标的Agent比较高层概述&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Agent Arena 的核心是允许基于目标的Agent比较。从高层次来看，用户首先输入他们想要完成的任务。然后，LLM 会根据任务自动分配相关Agent。这些Agent随后被指派完成目标，Agent的行动和&lt;em&gt;思维链&lt;&#x2F;em&gt;会实时传输给用户。一旦Agent完成任务，用户可以并排比较输出结果，并对哪个Agent表现更好进行投票。&lt;&#x2F;p&gt;
&lt;p&gt;评估过程包括对Agent性能进行投票，用户评估哪个Agent更有效地满足了任务要求。这种用户驱动的评估有助于形成一个不断发展的排行榜系统，该系统根据Agent在多个任务和竞赛中的相对表现对其进行排名。这种比较不仅限于Agent整体，还延伸到构成每个Agent的各个组件(即 LLM 模型、工具和框架)。&lt;&#x2F;p&gt;
&lt;p&gt;在下面的章节中，我们将深入探讨 Agent Arena 的核心组件，包括路由系统、执行、评估和排名机制、排行榜和提示中心。我们还将探索一些可以在平台上执行的示例任务和应用。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;lu-you-xi-tong-agentpi-pei-he-ren-wu-fen-pei&quot;&gt;路由系统:Agent匹配和任务分配&lt;&#x2F;h2&gt;
&lt;p&gt;Agent Arena 的一个核心要素是其路由系统，目前由 GPT-4o 驱动。我们计划在所有模型之间轮换，并评估每个模型，使用提示词将其路由到最相关Agents上! 路由系统的主要功能是将用户指定的目标与平台上最合适的Agent进行匹配。&lt;&#x2F;p&gt;
&lt;p&gt;路由系统通过分析用户的输入(目标或任务)来运作，并选择两个最适合完成该任务的Agent。这个选择过程会考虑Agent在类似任务中的历史表现，以及它们在模型、工具和框架方面的配置。&lt;&#x2F;p&gt;
&lt;p&gt;例如，用户可能提供以下输入:&lt;code&gt;input(&amp;quot;Tell me about whats going on in NVIDIA in the last week.&amp;quot;)&lt;&#x2F;code&gt; 然后，路由系统会根据可用的Agent和排行榜 ELO 分数选择两个合适的选项。对于这个用例，路由系统可能会选择Agent &lt;code&gt;agent_a = Agent(model=&amp;quot;GPT-4o&amp;quot;， tools=[&amp;quot;Yahoo Finance&amp;quot;， &amp;quot;Matplotlib&amp;quot;]， framework=&amp;quot;Langchain&amp;quot;)&lt;&#x2F;code&gt; 来分析 NVIDIA 的股票信息。另一方面，为了与Agent A 进行比较，路由系统可能会选择组合: &lt;code&gt;agent_b = Agent(model=&amp;quot;Claude&amp;quot;， tools=[&amp;quot;Yahoo News&amp;quot;]， framework=&amp;quot;CrewAI&amp;quot;)&lt;&#x2F;code&gt; 从新闻的角度来观察目标。&lt;&#x2F;p&gt;
&lt;p&gt;这种比较是有成效的，因为它让平台和用户能够理解Agent能力的细微差别以及它们处理相同任务的不同方式。然后，用户可以对他们更喜欢的风格进行投票。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;ping-gu-he-pai-ming-xi-tong&quot;&gt;评估和排名系统&lt;&#x2F;h2&gt;
&lt;p&gt;Agent Arena 采用全面的排名系统，基于Agent在一对一比较中的表现进行评估。排行榜不仅根据Agent的整体表现进行排名，还会分解各个组件(如 LLM 模型、工具和框架)的表现。排名过程参考了用户评估和基于 ELO 的评分系统，这在竞争性排名环境中很常见，Agent的表现在每次任务或比较后都会动态调整。&lt;&#x2F;p&gt;
&lt;p&gt;Agent Arena 的评分系统旨在反映Agent在广泛任务中的累积表现，考虑以下因素:&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;oss-ata.alibaba.com&#x2F;article&#x2F;2025&#x2F;01&#x2F;fc4ac1e9-d733-41a9-8e30-1c4a93e95dd7.png&quot; alt=&quot;img&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;em&gt;分析Agent子组件的排行榜&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;模型表现:&lt;&#x2F;strong&gt; 评估底层 LLM 模型的效果(如 GPT-4、Claude、Llama 3.1)。&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;工具效率:&lt;&#x2F;strong&gt; 对Agent用于完成任务的工具进行排名(如代码解释器、Brave Search 或 Yahoo Finance 等 API)。&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;框架功能:&lt;&#x2F;strong&gt; 评估支持Agent的更广泛框架，如 LangChain、LlamaIndex 和 CrewAI。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;查看我们排行榜上各类别的最新排名:&lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.agent-arena.com&#x2F;leaderboard&quot;&gt;Agent Arena 排行榜&lt;&#x2F;a&gt;。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;scales-shi-yong-extended-bradley-terry-mo-xing-ping-gu-agent&quot;&gt;⚖️ 使用Extended Bradley-Terry 模型评估Agent&lt;&#x2F;h3&gt;
&lt;h3 id=&quot;extended-bradley-terry-mo-xing&quot;&gt;Extended Bradley-Terry 模型&lt;&#x2F;h3&gt;
&lt;p&gt;Agent Arena 使用 &lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;blog.lmarena.ai&#x2F;blog&#x2F;2024&#x2F;extended-arena&#x2F;&quot;&gt;Bradley-Terry 扩展&lt;&#x2F;a&gt;，这使我们能够基于Agent的子组件(包括工具、模型和框架)来比较不同的Agent。我们不仅仅是对Agent进行整体评估，还会评估每个独立子组件的表现。这让我们能够更准确地找出Agent的优势所在。例如，我们的第一个Agent可能是 LangChain、Brave-Search 和 GPT-4o-2024-08-06 的组合，而第二个Agent可能是 LlamaIndex、Wikipedia 和 Claude-3-5-Sonnet-20240620。因此，我们为扩展 Bradley-Terry 模型提出以下观察模型。给定 &lt;code&gt;P_1&lt;&#x2F;code&gt;，&lt;&#x2F;p&gt;
&lt;p&gt;对于每场对战 𝑖∈[𝑛]，我们有一个提示和两个Agent，编码如下:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Agent A&lt;&#x2F;code&gt;: 第一个被比较的Agent，ELO 分数为 &lt;code&gt;E_A&lt;&#x2F;code&gt;，子组件为 &lt;code&gt;(A_T， A_M， A_F)&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;Agent B&lt;&#x2F;code&gt;: 第二个被比较的Agent，ELO 分数为 &lt;code&gt;E_B&lt;&#x2F;code&gt;，子组件为 &lt;code&gt;(B_T， B_M， B_F)&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;Y_i&lt;&#x2F;code&gt;: 对战结果(1 表示胜利，0 表示失败)&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h4 id=&quot;older-computer-shi-li-langchain-brave-search-agent-vs-llamaindex-wikipedia-agent&quot;&gt;🧑‍💻 示例: LangChain Brave-Search Agent vs. LlamaIndex Wikipedia Agent&lt;&#x2F;h4&gt;
&lt;p&gt;让我们通过一个例子来说明扩展 Bradley-Terry 模型在实践中是如何工作的。以下面的Agent及其子组件为例:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Agent A&lt;&#x2F;code&gt; 是 Langchain Brave-Search Agent，使用以下子组件: &lt;code&gt;{ Brave-Search (A_T)， LangChain (A_F)， 和 GPT-4o-2024-08-06 (A_M) }&lt;&#x2F;code&gt;，ELO 分数为 1600。&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;Agent B&lt;&#x2F;code&gt; 是 LlamaIndex Wikipedia Agent，子组件为: &lt;code&gt;{Wikipedia (B_T)， LlamaIndex (B_F)， 和 Claude-3-5-Sonnet-20240620 (B_M)}&lt;&#x2F;code&gt;，ELO 分数为 1500。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;在传统的 ELO 系统中，我们会计算 Brave-Search Agent获胜概率为 64%。然后根据实际对战结果 &lt;code&gt;Y_1&lt;&#x2F;code&gt;，假设 Brave-Search Agent获胜，Agent的新评分将分别为 1601.44 和 1498.56。&lt;&#x2F;p&gt;
&lt;p&gt;然而，在 Bradley-Terry 模型中，我们通过最小化以下损失函数来计算评分，给定实际对战结果 &lt;code&gt;Y_i&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;p&gt;$$ L = -\sum_{i = 1}^{n} Y_{i} \cdot \log(\frac{1}{1 + e^{E_{A}-E_{B}}}) + (1 - Y_{i}) \cdot \log(\frac{1}{1 + e^{E_{B}-E_{A}}}) $$&lt;&#x2F;p&gt;
&lt;p&gt;最后，为了对Agent进行整体评估，我们将其所有子组件合并到单一分析中。我们不是将每个子组件作为独立实体处理，而是考虑它们在更广泛的Agent架构中的相互作用。对于每场对战，我们构建一个设计矩阵 &lt;code&gt;X&lt;&#x2F;code&gt;，代表所有涉及的子组件。在这里，假设 A(Brave-Search Agent)赢得了对战，那么设计矩阵将如下所示:&lt;&#x2F;p&gt;
&lt;p&gt;$$ X = [+\log(A_{T})， +\log(A_{M})， +\log(A_{F})， -\log(B_{T})， -\log(B_{M})， -\log(B_{F})] $$&lt;&#x2F;p&gt;
&lt;p&gt;这使我们能够在单一计算中评估子组件(工具、模型、框架)的集体贡献。然后我们应用带有 L2 正则化的逻辑回归，以控制由频繁配对导致的过拟合和混淆效应。&lt;&#x2F;p&gt;
&lt;p&gt;通过使用这种组合方法，Agent Arena 确保了对Agent及其子组件进行更准确的排名。🔄 这种方法为每个Agent的表现和贡献提供了更清晰的洞察，防止了由频繁配对或过度使用的配置导致的偏差。&lt;&#x2F;p&gt;
&lt;p&gt;🎉 因此，我们的系统生成了一个实时、持续更新的排行榜，不仅反映了Agent的整体表现，还反映了它们特定子组件的优势。🏆&lt;&#x2F;p&gt;
&lt;p&gt;查看我们的Agent、工具、模型和框架的实时排行榜&lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.agent-arena.com&#x2F;leaderboard&quot;&gt;点击这里&lt;&#x2F;a&gt;!&lt;&#x2F;p&gt;
&lt;h2 id=&quot;ti-shi-ci-zhong-xin&quot;&gt;提示词中心&lt;&#x2F;h2&gt;
&lt;p&gt;Agent Arena 还包含一个提示词中心，其中有超过 1000+ 个经过测试和验证可在平台上运行的任务。用户可以搜索与他们类似的用例，并观察不同提示是如何执行和表现的。此外，平台还允许用户向社区发布他们的提示。这种对通过 agent arena 评估的提示的公开视图为未来的代理开发和评估提供了强大的基础设施和数据。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;oss-ata.alibaba.com&#x2F;article&#x2F;2025&#x2F;01&#x2F;acd41109-c94e-45e9-b688-74d2c6f577e6.jpeg?x-oss-process=image%2Fauto-orient%2C1%2Fresize%2Cm_lfit%2Cw_1600%2Fquality%2CQ_80%2Fformat%2Cwebp&quot; alt=&quot;img&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;em&gt;展示竞技场中注册用户的提示词中心&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;h3 id=&quot;house-ti-shi-zhong-xin-gai-shu&quot;&gt;🏠 提示中心概述&lt;&#x2F;h3&gt;
&lt;p&gt;提示词中心是用户与其他用户互动并查看用户对代理的个人和领域特定用例需求的独特视角的方式。这是一个很好的方式来从细粒度层面查看用户活动，了解用户具体使用Agent做什么以及如何优先考虑未来的Agent开发。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;oss-ata.alibaba.com&#x2F;article&#x2F;2025&#x2F;01&#x2F;a65a019f-b364-4302-923d-7c0a21642260.jpeg?x-oss-process=image%2Fauto-orient%2C1%2Fresize%2Cm_lfit%2Cw_1600%2Fquality%2CQ_80%2Fformat%2Cwebp&quot; alt=&quot;img&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;em&gt;查看、点赞和点踩个人用户提示词&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;h3 id=&quot;older-computer-ge-ren-yong-hu-shi-tu&quot;&gt;🧑‍💻 个人用户视图&lt;&#x2F;h3&gt;
&lt;p&gt;此外，用户可以通过在提示词中心对其他用户的个别提示词进行点赞和点踩来提供反馈。这为未来的提示分析提供了额外的数据点，以潜在评估竞技场中各种代理在特定领域的表现。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;briefcase-an-li-yan-jiu&quot;&gt;💼 案例研究&lt;&#x2F;h2&gt;
&lt;p&gt;您选择的模型、框架和工具通常会根据领域应用和用例而有很大差异。特定领域的代理开发者需要找到这些因素的最佳组合以最大化性能。未来的愿景是，最终代理将变得足够准确，以至于我们可以让它们在不需要人工参与的情况下做出明智甚至关键的决策。虽然还有很长的路要走，但以下是一些可能被代理颠覆的行业:&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;oss-ata.alibaba.com&#x2F;article&#x2F;2025&#x2F;01&#x2F;aab290de-a053-4b66-9442-1f58b455931d.png&quot; alt=&quot;代理分析师示例&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;em&gt;LLM Agent根据相关收益和竞争对手提供通用电气股票价格预测和见解的示例流程&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;h3 id=&quot;zhen-shi-shi-jie-agentgong-zuo-liu-cheng-you-qu-de-yong-hu-chang-jing&quot;&gt;真实世界Agent工作流程:有趣的用户场景&lt;&#x2F;h3&gt;
&lt;p&gt;在以下部分，我们展示了来自 Agent Arena 的一些最有趣的真实示例。这些示例代表了不同的用户场景，Agent被要求解决特定挑战，突出了所使用的各种模型、框架和工具。每个提示都说明了Agent的思维过程、执行情况和需要改进的领域，为开发者和用户提供了见解。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;yong-li-shi-li&quot;&gt;用例示例&lt;&#x2F;h2&gt;
&lt;h5 id=&quot;jiao-yu-yu-ge-xing-hua-fu-dao-books&quot;&gt;教育与个性化辅导 📚&lt;&#x2F;h5&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;“为这道高中物理题生成逐步解答和解释:一个5公斤的物体从10米高处落下。需要多长时间才能落到地面?”&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;+ 提示执行&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;color:#c0c5ce;&quot;&gt;&lt;code&gt;&lt;span&gt;ref
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;在教育场景中，LLM Agent有潜力提供丰富的逐步解释，引导学生解决复杂问题，如物理计算。在确定5公斤物体从10米高处落下所需时间的例子中，Agents 使用基本运动方程来解决问题。然而，虽然&lt;strong&gt;AgentA&lt;&#x2F;strong&gt;(&lt;strong&gt;anthropic计算器工具， claude-3-opus-20240229&lt;&#x2F;strong&gt;)提供了详细的解决方案分解，但其方法的简单性突显了需要更细致地处理运动学，比如根据用户查询动态调整的自适应响应。同时，&lt;strong&gt;AgentB&lt;&#x2F;strong&gt;(&lt;strong&gt;langchain Wolfram Alpha， claude-3-haiku-20240307&lt;&#x2F;strong&gt;)虽然利用了Wolfram Alpha但在从工具获取相关数据时遇到困难，表明API集成存在影响实时计算准确性的缺陷。这些案例显示了在调整Agent与API和框架交互方面的机会，确保Agent不仅能检索正确数据，还能有效地处理并应用到实际场景中。改进这些计算的流畅性和深度，特别是在利用多个API时，可以在教育环境中带来更高的精确性和适应性，丰富学习体验并使Agent更能处理各种教育查询。&lt;&#x2F;p&gt;
&lt;h5 id=&quot;shang-ye-shu-ju-fen-xi-money-with-wings&quot;&gt;商业数据分析 💸&lt;&#x2F;h5&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;“给定这个去年销售数据的.csv文件，生成关于哪些产品需要扩大规模的见解。”&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;+ 提示执行&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;color:#c0c5ce;&quot;&gt;&lt;code&gt;&lt;span&gt;ref
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;在商业数据分析中，LLM Agent 可以通过处理大型数据集(如包含销售数据的CSV文件)来提供有价值的见解，发现趋势并提出战略建议。在这个例子中，&lt;strong&gt;AgentA&lt;&#x2F;strong&gt;(&lt;strong&gt;sqlAgent绘图器langchain， gpt-4o-2024-05-13&lt;&#x2F;strong&gt;)遇到了错误，将CSV文件误解为SQLite数据库，这突显了Agent在错误处理能力和适应不同文件格式方面的局限性。尽管Agent试图切换工具并纠正流程，但很明显需要在SQL和文件处理工具之间建立更无缝的集成以保持工作流的流畅性。同时，&lt;strong&gt;AgentB&lt;&#x2F;strong&gt;(&lt;strong&gt;langchain Pandas DataFrame， gpt-4o-2024-08-06&lt;&#x2F;strong&gt;)有效地分析了销售数据，根据销售收入识别出表现最好的产品如“笔记本电脑“和“智能手机“，并建议由于销售量高而扩大“耳机“和“键盘“的规模。然而，&lt;strong&gt;AgentB&lt;&#x2F;strong&gt;可以通过将销售模式与季节性或促销等外部因素联系起来，获得更深入的上下文理解。这些例子强调了Agent需要更好地处理复杂数据集、增强错误恢复能力，并提供更多上下文感知的分析，特别是在切换工具或处理不同数据格式时。改进这些领域将显著提升Agent提供更稳健、可操作见解的能力，特别是在复杂的商业场景中。&lt;&#x2F;p&gt;
&lt;h5 id=&quot;she-jiao-mei-ti-guan-li-nei-rong-chuang-zuo-camera-with-flash&quot;&gt;社交媒体管理&#x2F;内容创作 📸&lt;&#x2F;h5&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;“安排一周的每日 Instagram 帖子，使用相关标签和当前网红趋势来推广我们即将举行的促销活动。”&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;+ 提示执行&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;color:#c0c5ce;&quot;&gt;&lt;code&gt;&lt;span&gt;ref
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;在这个例子中，由于Agent的通用性质，安排一周的每日 Instagram 帖子并使用相关标签和网红趋势的任务并未完全实现。两个代理—&lt;strong&gt;langchain google-serper search agent (gemini-1.5-pro-001)&lt;&#x2F;strong&gt; 和 &lt;strong&gt;langchain You.com Search (gpt-4o-mini-2024-07-18)&lt;&#x2F;strong&gt;—都尝试创建内容并建议标签，但缺乏处理细致的社交媒体调度任务所需的特定功能。&lt;strong&gt;gemini-1.5-pro-001&lt;&#x2F;strong&gt; 代理不断循环询问有关促销的更多信息，而 &lt;strong&gt;You.com&lt;&#x2F;strong&gt; 代理则专注于为期一周的帖子日程的一般性建议，没有实时参与度洞察或基于平台特定趋势的自适应内容创作。&lt;&#x2F;p&gt;
&lt;p&gt;例如，&lt;strong&gt;gemini-1.5-pro-001&lt;&#x2F;strong&gt; 代理的输出重复询问促销详情，这表明在处理上下文方面存在局限性。此外，响应结构未考虑 Instagram 的独特功能，如最佳发布时间或 Story 集成。同时，&lt;strong&gt;gpt-4o-mini-2024-07-18&lt;&#x2F;strong&gt; 代理提供了一个不错的帖子日程，但没有充分利用网红数据或实时趋势来指导其内容建议。&lt;&#x2F;p&gt;
&lt;p&gt;这些代理虽然可以运作，但表明需要更专门的框架来适应社交媒体平台。集成与 Instagram、Twitter 或 Facebook 等平台直接连接，并整合最新社交媒体参与度分析的框架，将使代理能够生成更精确、更具平台特异性的建议。此外，代理可以从直接处理任务(如调度帖子)中受益，而不是仅生成内容想法，这将使它们在简化社交媒体策略方面更加有效。&lt;&#x2F;p&gt;
&lt;h5 id=&quot;yi-liao-zhen-duan-ok-wom&quot;&gt;医疗诊断 👩‍⚕️&lt;&#x2F;h5&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;“根据这份包含患者病史的文件，与最新研究论文交叉参考，为慢性偏头痛推荐最新的治疗方案。”&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;+ 提示执行&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;color:#c0c5ce;&quot;&gt;&lt;code&gt;&lt;span&gt;ref
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;手动筛选医学研究不仅耗时，而且在数据跨越众多临床试验和不断发展的治疗方案时容易出现疏漏。LLM Agent提供了一个强大的替代方案，擅长梳理广泛的医学数据库，提取相关发现，并将其与特定患者病况联系起来。在慢性偏头痛等病例中，Agent可以迅速收集关于有效治疗的最新研究，如预防性治疗 erenumab 和提供长期头痛缓解的射频消融(RFA)。例如，在这个案例中，&lt;strong&gt;langchain PubMed 生物医学文献工具(gpt-4o-mini-2024-07-18)&lt;&#x2F;strong&gt; 代理成功检索到相关研究，根据最新发现提出具体的治疗方案。相比之下，&lt;strong&gt;ArXiv 文章获取器(claude-3-haiku-20240307)&lt;&#x2F;strong&gt; 由于 ArXiv 专注于预印本而非临床治疗而遇到困难。尽管如此，建议查看更适合的医学期刊(如 JAMA)的后备建议，显示了Agent在遇到限制时如何适应。加强与专业数据库的集成并改进多步查询处理可以释放更多潜力，使这些代理能够提供更快速、更准确和更具上下文相关性的医疗建议，最终推动自动化系统如何支持医疗决策的边界。&lt;&#x2F;p&gt;
&lt;h5 id=&quot;ti-yu-shu-ju-fen-xi-basketball&quot;&gt;体育数据分析 🏀&lt;&#x2F;h5&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;“根据球员个人数据、球队表现趋势和最近的交易新闻，预测丹佛掘金队赢得NBA冠军的概率。”&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;+ 提示执行&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;color:#c0c5ce;&quot;&gt;&lt;code&gt;&lt;span&gt;ref
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;在体育数据分析中，LLM Agent需要分析球员统计数据、球队表现和交易新闻来预测结果，比如丹佛掘金队赢得NBA冠军的可能性。&lt;strong&gt;Agent A&lt;&#x2F;strong&gt;(&lt;strong&gt;langchain google-serper search agent， open-mixtral-8x22b&lt;&#x2F;strong&gt;)收集了相关数据，但缺乏深入分析，忽略了关键洞察如球员受伤或其他球队的竞争情况。同样，&lt;strong&gt;Agent B&lt;&#x2F;strong&gt;(&lt;strong&gt;anthropic web page reader， claude-3-5-sonnet-20240620&lt;&#x2F;strong&gt;)强调了实时数据的重要性，但由于缺乏当前赛季的统计数据而无法提供详细的数据驱动预测。&lt;&#x2F;p&gt;
&lt;p&gt;这两个Agent都突显了需要更好地整合实时数据源和更先进的统计建模。改进这些代理处理多步推理和预测分析的方式将显著提升它们提供准确、可操作洞察的能力，使它们对依赖此类预测进行决策的球队、分析师和体育博彩者更有价值。&lt;&#x2F;p&gt;
&lt;h5 id=&quot;lu-xing-gui-hua&quot;&gt;旅行规划 ✈️&lt;&#x2F;h5&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;“规划一次从旧金山到卡梅尔海滩的一日游。通过选择最省油的路线和最多景点来优化行程。”&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;+ 提示执行&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;color:#c0c5ce;&quot;&gt;&lt;code&gt;&lt;span&gt;ref
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;在旅行规划中，LLM Agent有潜力通过优化路线和建议相关停靠点来制定详细的行程。在规划从旧金山到卡梅尔海滩一日游的例子中，&lt;strong&gt;Agent A&lt;&#x2F;strong&gt;(&lt;strong&gt;crewai AI Crew for Trip Planning， gemini-1.5-pro-002&lt;&#x2F;strong&gt;)和&lt;strong&gt;Agent B&lt;&#x2F;strong&gt;(&lt;strong&gt;langchain google-serper search agent， open-mixtral-8x22b&lt;&#x2F;strong&gt;)都建议了省油路线和热门景点。然而，虽然&lt;strong&gt;Agent B&lt;&#x2F;strong&gt;高效地识别了主要地标并提供了清晰的路线，但响应缺乏基于实时条件(如交通或道路封闭)的动态调整。&lt;&#x2F;p&gt;
&lt;p&gt;此外，&lt;strong&gt;Agent A&lt;&#x2F;strong&gt;在工具之间的无缝过渡方面存在困难，这影响了充分整合相关行程数据的能力。这些例子指出了通过增强实时API集成和提高代理对变化的旅行条件的适应性，可以提供更个性化和准确的行程规划。更好地处理当前道路状况或用户特定偏好等动态因素将带来更丰富、更相关的旅行体验。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;xia-yi-bu-ji-hua-he-xiang-mu-lu-xian-tu&quot;&gt;下一步计划和项目路线图&lt;&#x2F;h2&gt;
&lt;p&gt;我们为 Agent Arena 制定了令人兴奋的路线图，计划了几项举措来增强和扩展平台的功能。我们设想 agent arena 将成为Agent开发者和提供商的中心枢纽。&lt;&#x2F;p&gt;
&lt;p&gt;对于有兴趣构建&#x2F;使用Agent的开发者和用户来说，该平台将成为他们完善Agent技术栈的沙盒，提供适合其用例的正确提供商和框架。&lt;&#x2F;p&gt;
&lt;p&gt;通过提供系统化的方式来运行Agent、相互比较、查看基于用例的提供商高级分析，甚至查看类似用户的提示，我们希望为Agent构建社区提供价值。&lt;&#x2F;p&gt;
&lt;p&gt;为了实现这一愿景，我们制定了全面的功能开发和改进路线图。这些变更的总体主题将是改善竞技场对个别用户的个性化，同时扩展可用的分析功能。&lt;&#x2F;p&gt;
&lt;h5 id=&quot;chart-with-upwards-trend-zeng-jia-ping-tai-shang-de-llm-he-kuang-jia-ti-gong-shang-shu-liang&quot;&gt;📈 增加平台上的 LLM 和框架提供商数量&lt;&#x2F;h5&gt;
&lt;p&gt;Agent Arena 的主要目标之一是向用户展示他们可以构建的所有Agent组合，让他们能够确定哪些选项最适合他们的用例。虽然我们目前在每个类别中都提供主要的提供商，但我们希望扩大选择范围，纳入更多专注于特定任务的小众提供商。&lt;&#x2F;p&gt;
&lt;h5 id=&quot;older-computer-jia-ru-yong-hu-ge-xing-hua&quot;&gt;🧑‍💻 加入用户个性化&lt;&#x2F;h5&gt;
&lt;p&gt;为了使平台尽可能实用，我们希望确保用户能够获得关于最新发布和最适合其用例的Agent的具体推荐。这将涉及我们学习他们对提供商和输出格式的偏好，使我们能够为他们推荐最佳Agent。&lt;&#x2F;p&gt;
&lt;h5 id=&quot;qi-yong-duo-lun-ti-shi&quot;&gt;🪜 启用多轮提示&lt;&#x2F;h5&gt;
&lt;p&gt;大多数Agent任务都涉及Agent的多个推理和行动步骤。这需要跟踪任务上下文的状态。例如，看看以下任务:&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;任务:&lt;&#x2F;strong&gt; “搜索标准普尔500指数中今年表现最好的5只股票，然后找出关于它们的最新新闻。”&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;这个任务需要Agent首先找到前5只股票，将其保存在后端’内存’中，然后调用另一组单独的工具来查找关于它们的最新新闻。这是一个多轮提示，其他示例可能会涉及5个以上的步骤。我们计划在未来几个月内为用户发布这项功能。&lt;&#x2F;p&gt;
&lt;h5 id=&quot;weightlifter-kuo-zhan-ping-tai-de-gong-neng&quot;&gt;🏋️‍♀️ 扩展平台的功能&lt;&#x2F;h5&gt;
&lt;p&gt;平台的当前实现还有几个Agent用例领域未被探索。更具体地说，我们希望开始与Jira、Github、GSuite等API集成，使用户能够在他们的个人数据上实际运行Agent。虽然这将涉及许多安全和隐私考虑，但我们相信这是使平台对用户更有用的关键一步。&lt;&#x2F;p&gt;
&lt;h5 id=&quot;bar-chart-gai-jin-tui-jian-suan-fa&quot;&gt;📊 改进推荐算法&lt;&#x2F;h5&gt;
&lt;p&gt;基于用户偏好和他们喜欢的提供商&#x2F;框架，我们计划改进目标到更相关Agent的路由。此外，我们将包括两种不同的路由模式:一种更具探索性，另一种更专注于用户的偏好。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;jie-lun&quot;&gt;结论&lt;&#x2F;h2&gt;
&lt;p&gt;Agent Arena 是一个评估和比较 LLM Agent的平台。通过提供全面的排名系统和测试各种框架Agent的工具，该平台使用户能够就其特定需求的最佳模型和工具做出明智的决定。随着计划中的持续改进和扩展，Agent Arena 将在塑造 LLM Agent评估的未来方面发挥关键作用。&lt;&#x2F;p&gt;
&lt;p&gt;我们邀请研究人员、开发者和 AI 爱好者探索 Agent Arena，为其成长做出贡献，并帮助塑造基于Agent的 AI 系统的未来。让我们一起推动 LLM Agent可能性的边界，释放 AI 驱动问题解决的新潜力。&lt;&#x2F;p&gt;
&lt;hr &#x2F;&gt;
&lt;p&gt;我们希望您喜欢这篇博文。我们很乐意在 &lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;discord.gg&#x2F;grXXvj9Whz&quot;&gt;Discord&lt;&#x2F;a&gt;、&lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;twitter.com&#x2F;shishirpatil_&#x2F;status&#x2F;1661780076277678082&quot;&gt;Twitter (#GorillaLLM)&lt;&#x2F;a&gt; 和 &lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;ShishirPatil&#x2F;gorilla&#x2F;&quot;&gt;GitHub&lt;&#x2F;a&gt; 上听取您的意见。&lt;&#x2F;p&gt;
&lt;h4 id=&quot;yin-yong&quot;&gt;引用&lt;&#x2F;h4&gt;
&lt;p&gt;如果您想引用 Agent Arena:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;color:#c0c5ce;&quot;&gt;&lt;code&gt;&lt;span&gt;@inproceedings{agent-arena，
&lt;&#x2F;span&gt;&lt;span&gt;            title={Agent Arena}，
&lt;&#x2F;span&gt;&lt;span&gt;            author={Nithik Yekollu and Arth Bohra and Ashwin Chirumamilla and Kai Wen and Sai Kolasani
&lt;&#x2F;span&gt;&lt;span&gt;                    Wei-Lin Chiang and Anastasios Angelopoulos and Joseph E. Gonzalez and
&lt;&#x2F;span&gt;&lt;span&gt;                    Ion Stoica and Shishir G. Patil}，
&lt;&#x2F;span&gt;&lt;span&gt;            year={2024}，
&lt;&#x2F;span&gt;&lt;span&gt;            howpublished={\url{https:&#x2F;&#x2F;gorilla.cs.berkeley.edu&#x2F;blogs&#x2F;14_agent_arena.html}}，
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;hr &#x2F;&gt;
</content>
        
    </entry>
    <entry xml:lang="zh">
        <title>构建高效的智能体</title>
        <published>2025-01-13T00:00:00+00:00</published>
        <updated>2025-01-13T00:00:00+00:00</updated>
        <author>
          <name>Unknown</name>
        </author>
        <link rel="alternate" href="https://linq.github.io/posts/building-effective-agents/" type="text/html"/>
        <id>https://linq.github.io/posts/building-effective-agents/</id>
        
        <content type="html">&lt;blockquote&gt;
&lt;p&gt;近期 Anthropic 发布了一篇关于智能体系统的重要文章。他们预测 2025 年将是 Agentic 系统的关键年份,这个判断基于他们与众多行业团队合作开发 LLM 智能体的实践经验。&lt;&#x2F;p&gt;
&lt;p&gt;这篇综述文章总结了他们在构建 Agentic 系统过程中的关键发现和最佳实践。文章强调,成功的智能体实现往往采用简单、可组合的模式,而不是复杂的框架。对于想要开发智能体的团队来说,这是一份非常有价值的参考指南。&lt;&#x2F;p&gt;
&lt;p&gt;原文地址：https:&#x2F;&#x2F;www.anthropic.com&#x2F;blog&#x2F;building-efficient-agents&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;在过去一年中,我们与数十个跨行业团队合作构建大语言模型(LLM)智能体。我们发现,最成功的实现并非使用复杂的框架或专门的库,而是采用简单、可组合的模式进行构建。&lt;&#x2F;p&gt;
&lt;p&gt;在这篇文章中,我们分享了与客户合作和自主构建智能体过程中的经验,并为开发者提供构建高效智能体的实用建议。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;shi-yao-shi-zhi-neng-ti&quot;&gt;什么是智能体?&lt;&#x2F;h2&gt;
&lt;p&gt;“智能体“可以有多种定义。一些客户将智能体定义为能够长期独立运行、使用各种工具完成复杂任务的完全自主系统。另一些则用这个术语描述更具规范性的、遵循预定工作流程的实现。在 Anthropic,我们将所有这些变体都归类为&lt;strong&gt;智能系统&lt;&#x2F;strong&gt;,但在架构上区分&lt;strong&gt;工作流&lt;&#x2F;strong&gt;和&lt;strong&gt;智能体&lt;&#x2F;strong&gt;:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;工作流&lt;&#x2F;strong&gt;是通过预定义的代码路径来编排 LLM 和工具的系统。&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;智能体&lt;&#x2F;strong&gt;则是 LLM 能够动态指导自身流程和工具使用的系统,可以控制如何完成任务。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;下文我们将详细探讨这两种智能系统。在附录 1(“实践中的智能体”)中,我们描述了客户在使用这些系统时发现特别有价值的两个领域。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;he-shi-yi-ji-he-shi-bu-shi-yong-zhi-neng-ti&quot;&gt;何时(以及何时不)使用智能体&lt;&#x2F;h2&gt;
&lt;p&gt;在构建 LLM 应用时,我们建议寻找最简单的解决方案,只在必要时增加复杂性。这可能意味着完全不构建智能系统。智能系统通常会用延迟和成本来换取更好的任务表现,你需要考虑这种权衡是否合理。&lt;&#x2F;p&gt;
&lt;p&gt;当需要更多复杂性时,工作流为定义明确的任务提供可预测性和一致性,而智能体则在需要灵活性和模型驱动决策的规模化场景中更为适用。然而,对于许多应用来说,通过检索和上下文示例优化单个 LLM 调用通常就足够了。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;he-shi-yi-ji-ru-he-shi-yong-kuang-jia&quot;&gt;何时以及如何使用框架&lt;&#x2F;h2&gt;
&lt;p&gt;有许多框架可以让智能系统的实现变得更容易,包括:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;LangChain 的 &lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;langchain-ai.github.io&#x2F;langgraph&#x2F;&quot;&gt;LangGraph&lt;&#x2F;a&gt;;&lt;&#x2F;li&gt;
&lt;li&gt;Amazon Bedrock 的 &lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;aws.amazon.com&#x2F;bedrock&#x2F;agents&#x2F;&quot;&gt;AI Agent framework&lt;&#x2F;a&gt;;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;rivet.ironcladapp.com&#x2F;&quot;&gt;Rivet&lt;&#x2F;a&gt;,一个拖放式 GUI LLM 工作流构建器;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.vellum.ai&#x2F;&quot;&gt;Vellum&lt;&#x2F;a&gt;,另一个用于构建和测试复杂工作流的 GUI 工具。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;这些框架通过简化标准的底层任务(如调用 LLM、定义和解析工具、链接调用等)使入门变得容易。但是,它们往往会创建额外的抽象层,掩盖底层的提示和响应,使调试变得更困难。它们也可能诱使开发者在更简单的设置就足够的情况下增加复杂性。&lt;&#x2F;p&gt;
&lt;p&gt;我们建议开发者从直接使用 LLM API 开始:许多模式只需几行代码就能实现。如果你确实使用框架,请确保理解底层代码。对底层实现的错误假设是客户常见的错误来源。&lt;&#x2F;p&gt;
&lt;p&gt;可以参考我们的&lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;anthropics&#x2F;anthropic-cookbook&#x2F;tree&#x2F;main&#x2F;patterns&#x2F;agents&quot;&gt;cookbook&lt;&#x2F;a&gt;获取一些示例实现。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;gou-jian-mo-kuai-gong-zuo-liu-he-zhi-neng-ti&quot;&gt;构建模块、工作流和智能体&lt;&#x2F;h2&gt;
&lt;p&gt;在本节中,我们将探讨生产环境中常见的智能系统模式。我们将从基础构建模块——增强型 LLM 开始,逐步增加复杂性,从简单的组合工作流到自主智能体。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;gou-jian-mo-kuai-zeng-qiang-xing-llm&quot;&gt;构建模块:增强型 LLM&lt;&#x2F;h3&gt;
&lt;p&gt;智能系统的基本构建模块是经过检索、工具和记忆等功能增强的 LLM。我们当前的模型可以主动使用这些功能——生成自己的搜索查询、选择适当的工具,并确定需要保留哪些信息。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;www.anthropic.com&#x2F;_next&#x2F;image?url=https%3A%2F%2Fwww-cdn.anthropic.com%2Fimages%2F4zrzovbb%2Fwebsite%2Fd3083d3f40bb2b6f477901cc9a240738d3dd1371-2401x1000.png&amp;amp;w=3840&amp;amp;q=75&quot; alt=&quot;The augmented LLM&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;我们建议关注实现的两个关键方面:根据具体用例定制这些功能,并确保它们为 LLM 提供简单、文档完善的接口。虽然有多种方式实现这些增强功能,一种方法是通过我们最近发布的&lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.anthropic.com&#x2F;news&#x2F;model-context-protocol&quot;&gt;模型上下文协议&lt;&#x2F;a&gt;,它允许开发者通过简单的&lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;modelcontextprotocol.io&#x2F;tutorials&#x2F;building-a-client#building-mcp-clients&quot;&gt;客户端实现&lt;&#x2F;a&gt;与不断增长的第三方工具生态系统集成。&lt;&#x2F;p&gt;
&lt;p&gt;在本文的其余部分,我们假设每个 LLM 调用都能访问这些增强功能。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;gong-zuo-liu-ti-shi-lian&quot;&gt;工作流:提示链&lt;&#x2F;h3&gt;
&lt;p&gt;提示链将任务分解为一系列步骤,每个 LLM 调用处理前一个调用的输出。你可以在任何中间步骤添加程序化检查(见下图中的“gate“),以确保流程仍在正轨上。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;www.anthropic.com&#x2F;_next&#x2F;image?url=https%3A%2F%2Fwww-cdn.anthropic.com%2Fimages%2F4zrzovbb%2Fwebsite%2F7418719e3dab222dccb379b8879e1dc08ad34c78-2401x1000.png&amp;amp;w=3840&amp;amp;q=75&quot; alt=&quot;The prompt chaining workflow&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;何时使用此工作流:&lt;&#x2F;strong&gt; 当任务可以轻松清晰地分解为固定子任务时,这种工作流最为理想。主要目标是通过让每个 LLM 调用成为更简单的任务来用延迟换取更高的准确性。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;提示链有用的示例:&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;生成营销文案,然后将其翻译成不同语言。&lt;&#x2F;li&gt;
&lt;li&gt;写一份文档大纲,检查大纲是否符合特定标准,然后基于大纲写文档。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h3 id=&quot;gong-zuo-liu-lu-you&quot;&gt;工作流:路由&lt;&#x2F;h3&gt;
&lt;p&gt;路由对输入进行分类并将其引导到专门的后续任务。这种工作流允许关注点分离,并构建更专门化的提示。如果没有这种工作流,为一种输入优化可能会损害对其他输入的性能。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;www.anthropic.com&#x2F;_next&#x2F;image?url=https%3A%2F%2Fwww-cdn.anthropic.com%2Fimages%2F4zrzovbb%2Fwebsite%2F5c0c0e9fe4def0b584c04d37849941da55e5e71c-2401x1000.png&amp;amp;w=3840&amp;amp;q=75&quot; alt=&quot;The routing workflow&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;何时使用此工作流:&lt;&#x2F;strong&gt; 当复杂任务有明显的不同类别需要分别处理,且分类可以由 LLM 或更传统的分类模型&#x2F;算法准确处理时,路由效果很好。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;路由有用的示例:&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;将不同类型的客服查询(一般问题、退款请求、技术支持)引导到不同的下游流程、提示和工具。&lt;&#x2F;li&gt;
&lt;li&gt;将简单&#x2F;常见问题路由到 Claude 3.5 Haiku 等较小模型,将困难&#x2F;不寻常问题路由到 Claude 3.5 Sonnet 等更强大的模型,以优化成本和速度。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h3 id=&quot;gong-zuo-liu-bing-xing-hua&quot;&gt;工作流:并行化&lt;&#x2F;h3&gt;
&lt;p&gt;LLM 有时可以同时处理任务,其输出通过程序化方式聚合。这种工作流——并行化有两个主要变体:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;分段&lt;&#x2F;strong&gt;: 将任务分解为并行运行的独立子任务。&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;投票:&lt;&#x2F;strong&gt; 多次运行相同任务以获得多样化输出。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;www.anthropic.com&#x2F;_next&#x2F;image?url=https%3A%2F%2Fwww-cdn.anthropic.com%2Fimages%2F4zrzovbb%2Fwebsite%2F406bb032ca007fd1624f261af717d70e6ca86286-2401x1000.png&amp;amp;w=3840&amp;amp;q=75&quot; alt=&quot;The parallelization workflow&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;何时使用此工作流:&lt;&#x2F;strong&gt; 当任务可以并行化以提高速度,或需要多个视角&#x2F;尝试来获得更高置信度的结果时,并行化是有效的。对于需要考虑多个方面的复杂任务,LLM 通常在每个考虑点由单独的 LLM 调用处理时表现更好,这允许对每个具体方面进行专注关注。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;并行化有用的示例:&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;分段&lt;&#x2F;strong&gt;:
&lt;ul&gt;
&lt;li&gt;实现防护机制,一个模型实例处理用户查询,而另一个筛查不当内容或请求。这比让同一个 LLM 调用同时处理防护和核心响应表现更好。&lt;&#x2F;li&gt;
&lt;li&gt;自动化评估 LLM 性能,每个 LLM 调用评估模型在给定提示下的不同方面表现。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;投票&lt;&#x2F;strong&gt;:
&lt;ul&gt;
&lt;li&gt;审查代码中的漏洞,多个提示审查并在发现问题时标记代码。&lt;&#x2F;li&gt;
&lt;li&gt;评估给定内容是否不当,多个提示评估不同方面或要求不同投票阈值来平衡误报和漏报。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h3 id=&quot;gong-zuo-liu-bian-pai-zhe-gong-zuo-zhe&quot;&gt;工作流:编排者-工作者&lt;&#x2F;h3&gt;
&lt;p&gt;在编排者-工作者工作流中,一个中央 LLM 动态分解任务,将其委派给工作者 LLM,并综合他们的结果。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;www.anthropic.com&#x2F;_next&#x2F;image?url=https%3A%2F%2Fwww-cdn.anthropic.com%2Fimages%2F4zrzovbb%2Fwebsite%2F8985fc683fae4780fb34eab1365ab78c7e51bc8e-2401x1000.png&amp;amp;w=3840&amp;amp;q=75&quot; alt=&quot;The orchestrator-workers workflow&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;何时使用此工作流:&lt;&#x2F;strong&gt; 这种工作流非常适合无法预测所需子任务的复杂任务(例如在编码中,需要更改的文件数量和每个文件中更改的性质可能取决于具体任务)。虽然在拓扑结构上与并行化类似,但关键区别在于其灵活性——子任务不是预定义的,而是由编排者根据具体输入确定的。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;编排者-工作者有用的示例:&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;对多个文件进行复杂更改的编码产品。&lt;&#x2F;li&gt;
&lt;li&gt;涉及从多个来源收集和分析可能相关信息的搜索任务。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h3 id=&quot;gong-zuo-liu-ping-gu-zhe-you-hua-zhe&quot;&gt;工作流:评估者-优化者&lt;&#x2F;h3&gt;
&lt;p&gt;在评估者-优化者工作流中,一个 LLM 调用生成响应,而另一个在循环中提供评估和反馈。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;www.anthropic.com&#x2F;_next&#x2F;image?url=https%3A%2F%2Fwww-cdn.anthropic.com%2Fimages%2F4zrzovbb%2Fwebsite%2F14f51e6406ccb29e695da48b17017e899a6119c7-2401x1000.png&amp;amp;w=3840&amp;amp;q=75&quot; alt=&quot;The evaluator-optimizer workflow&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;何时使用此工作流:&lt;&#x2F;strong&gt; 当我们有明确的评估标准,且迭代改进能提供可衡量的价值时,这种工作流特别有效。判断是否适合的两个标志是:首先,当人类表达反馈时,LLM 响应可以得到明显改进;其次,LLM 能够提供这样的反馈。这类似于人类作者在创作精炼文档时可能经历的迭代写作过程。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;评估者-优化者有用的示例:&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;文学翻译,其中有一些译者 LLM 最初可能无法捕捉的细微差别,但评估者 LLM 可以提供有用的批评。&lt;&#x2F;li&gt;
&lt;li&gt;需要多轮搜索和分析以收集全面信息的复杂搜索任务,评估者决定是否需要进一步搜索。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h3 id=&quot;zhi-neng-ti&quot;&gt;智能体&lt;&#x2F;h3&gt;
&lt;p&gt;随着 LLM 在关键能力上日趋成熟——理解复杂输入、进行推理和规划、可靠地使用工具以及从错误中恢复,智能体正在生产环境中崭露头角。智能体通过与人类用户的命令或交互对话开始工作。一旦任务明确,智能体就会独立规划和运作,必要时会向人类寻求更多信息或判断。在执行过程中,智能体必须在每个步骤从环境中获取“基准事实“(如工具调用结果或代码执行)以评估其进展。智能体可以在检查点或遇到障碍时暂停以获取人类反馈。任务通常在完成时终止,但也常常包含停止条件(如最大迭代次数)以保持控制。&lt;&#x2F;p&gt;
&lt;p&gt;智能体可以处理复杂的任务,但其实现往往很简单。它们通常只是基于环境反馈在循环中使用工具的 LLM。因此,清晰周到地设计工具集及其文档至关重要。我们在附录 2(“工具的提示工程”)中详细阐述了工具开发的最佳实践。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;www.anthropic.com&#x2F;_next&#x2F;image?url=https%3A%2F%2Fwww-cdn.anthropic.com%2Fimages%2F4zrzovbb%2Fwebsite%2F58d9f10c985c4eb5d53798dea315f7bb5ab6249e-2401x1000.png&amp;amp;w=3840&amp;amp;q=75&quot; alt=&quot;Autonomous agent&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;何时使用智能体:&lt;&#x2F;strong&gt; 智能体适用于难以或无法预测所需步骤数量、且无法硬编码固定路径的开放性问题。LLM 可能需要多轮操作,你必须对其决策有一定程度的信任。智能体的自主性使其非常适合在可信环境中扩展任务。&lt;&#x2F;p&gt;
&lt;p&gt;智能体的自主性意味着更高的成本,以及错误累积的可能性。我们建议在沙盒环境中进行广泛测试,并配备适当的防护措施。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;智能体有用的示例:&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;以下示例来自我们自己的实现:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;一个用于解决 &lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.anthropic.com&#x2F;research&#x2F;swe-bench-sonnet&quot;&gt;SWE-bench 任务&lt;&#x2F;a&gt;的编码智能体,根据任务描述对多个文件进行编辑;&lt;&#x2F;li&gt;
&lt;li&gt;我们的&lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;anthropics&#x2F;anthropic-quickstarts&#x2F;tree&#x2F;main&#x2F;computer-use-demo&quot;&gt;“计算机使用“参考实现&lt;&#x2F;a&gt;,让 Claude 使用计算机完成任务。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;www.anthropic.com&#x2F;_next&#x2F;image?url=https%3A%2F%2Fwww-cdn.anthropic.com%2Fimages%2F4zrzovbb%2Fwebsite%2F4b9a1f4eb63d5962a6e1746ac26bbc857cf3474f-2400x1666.png&amp;amp;w=3840&amp;amp;q=75&quot; alt=&quot;High-level flow of a coding agent&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;h2 id=&quot;zu-he-he-ding-zhi-zhe-xie-mo-shi&quot;&gt;组合和定制这些模式&lt;&#x2F;h2&gt;
&lt;p&gt;这些构建模块并非强制性的。它们是开发者可以根据不同用例塑造和组合的常见模式。与任何 LLM 功能一样,成功的关键在于衡量性能并迭代实现。重申一点:只有在明确能改善结果时,才应考虑增加复杂性。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;zong-jie&quot;&gt;总结&lt;&#x2F;h2&gt;
&lt;p&gt;在 LLM 领域,成功不在于构建最复杂的系统,而在于构建适合你需求的正确系统。从简单的提示开始,通过全面评估优化它们,只有在更简单的解决方案不足时才添加多步骤智能系统。&lt;&#x2F;p&gt;
&lt;p&gt;在实现智能体时,我们尽量遵循三个核心原则:&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;保持智能体设计的&lt;strong&gt;简单性&lt;&#x2F;strong&gt;。&lt;&#x2F;li&gt;
&lt;li&gt;通过明确展示智能体的规划步骤来优先考虑&lt;strong&gt;透明性&lt;&#x2F;strong&gt;。&lt;&#x2F;li&gt;
&lt;li&gt;通过全面的工具&lt;strong&gt;文档和测试&lt;&#x2F;strong&gt;来精心打造智能体-计算机接口(ACI)。&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;框架可以帮助你快速入门,但在转向生产环境时,不要犹豫减少抽象层并使用基本组件构建。遵循这些原则,你可以创建不仅强大,而且可靠、可维护且受用户信任的智能体。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;zhi-xie&quot;&gt;致谢&lt;&#x2F;h3&gt;
&lt;p&gt;作者:Erik Schluntz 和 Barry Zhang。本文借鉴了我们在 Anthropic 构建智能体的经验,以及客户分享的宝贵见解,对此我们深表感谢。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;fu-lu-1-zhi-neng-ti-de-shi-jian-ying-yong&quot;&gt;附录 1: 智能体的实践应用&lt;&#x2F;h2&gt;
&lt;p&gt;我们与客户的合作揭示了两个特别有前景的 AI 智能体应用场景,它们展示了上述模式的实际价值。这两个应用都说明了智能体在以下任务中最能发挥价值:需要对话和行动的结合、有明确的成功标准、能够形成反馈循环,并且包含有意义的人类监督。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;a-ke-hu-zhi-chi&quot;&gt;A. 客户支持&lt;&#x2F;h3&gt;
&lt;p&gt;客户支持将熟悉的聊天机器人界面与通过工具集成实现的增强功能相结合。这非常适合更开放式的智能体,原因如下:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;支持互动自然地遵循对话流程,同时需要访问外部信息和执行操作;&lt;&#x2F;li&gt;
&lt;li&gt;可以集成工具来获取客户数据、订单历史和知识库文章;&lt;&#x2F;li&gt;
&lt;li&gt;可以通过程序化方式处理退款或更新工单等操作;&lt;&#x2F;li&gt;
&lt;li&gt;可以通过用户定义的解决方案清晰地衡量成功。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;几家公司通过基于使用量的定价模式证明了这种方法的可行性,他们只对成功解决的案例收费,这显示了他们对智能体效能的信心。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;b-bian-ma-zhi-neng-ti&quot;&gt;B. 编码智能体&lt;&#x2F;h3&gt;
&lt;p&gt;软件开发领域展现了 LLM 功能的巨大潜力,从代码补全发展到自主问题解决。智能体在这里特别有效,因为:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;代码解决方案可以通过自动化测试进行验证;&lt;&#x2F;li&gt;
&lt;li&gt;智能体可以使用测试结果作为反馈来迭代解决方案;&lt;&#x2F;li&gt;
&lt;li&gt;问题空间定义明确且结构化;&lt;&#x2F;li&gt;
&lt;li&gt;输出质量可以客观衡量。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;在我们自己的实现中,智能体现在可以仅基于拉取请求描述来解决 &lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.anthropic.com&#x2F;research&#x2F;swe-bench-sonnet&quot;&gt;SWE-bench Verified&lt;&#x2F;a&gt; 基准测试中的真实 GitHub 问题。然而,虽然自动化测试有助于验证功能,但人工审查对于确保解决方案符合更广泛的系统要求仍然至关重要。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;fu-lu-2-gong-ju-de-ti-shi-gong-cheng&quot;&gt;附录 2: 工具的提示工程&lt;&#x2F;h2&gt;
&lt;p&gt;无论你构建的是哪种智能系统,工具很可能都是你的智能体的重要组成部分。&lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.anthropic.com&#x2F;news&#x2F;tool-use-ga&quot;&gt;工具&lt;&#x2F;a&gt;使 Claude 能够通过在我们的 API 中指定其确切结构和定义来与外部服务和 API 交互。当 Claude 响应时,如果它计划调用工具,API 响应中会包含一个&lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;docs.anthropic.com&#x2F;en&#x2F;docs&#x2F;build-with-claude&#x2F;tool-use#example-api-response-with-a-tool-use-content-block&quot;&gt;工具使用块&lt;&#x2F;a&gt;。工具定义和规范应该得到与整体提示同等的提示工程关注。在这个简短的附录中,我们将描述如何对工具进行提示工程。&lt;&#x2F;p&gt;
&lt;p&gt;通常有几种方式可以指定相同的操作。例如,你可以通过编写差异或重写整个文件来指定文件编辑。对于结构化输出,你可以在 markdown 或 JSON 内返回代码。在软件工程中,这些差异是表面的,可以无损地从一种格式转换为另一种格式。然而,某些格式对 LLM 来说比其他格式更难编写。编写差异需要在写入新代码之前知道块头中有多少行在变化。在 JSON 中编写代码(相比 markdown)需要额外转义换行符和引号。&lt;&#x2F;p&gt;
&lt;p&gt;我们对决定工具格式的建议如下:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;给模型足够的标记来“思考“,避免它把自己写入死角。&lt;&#x2F;li&gt;
&lt;li&gt;保持格式接近模型在互联网上自然出现的文本。&lt;&#x2F;li&gt;
&lt;li&gt;确保没有格式“开销“,比如必须保持对数千行代码的准确计数,或对它写的任何代码进行字符串转义。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;一个经验法则是思考在人机界面(HCI)上投入了多少努力,并计划在创建良好的_智能体_-计算机界面(ACI)上投入同样多的努力。以下是一些实现方法:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;站在模型的角度思考。基于描述和参数,使用这个工具是否显而易见,还是需要仔细思考?如果是后者,那么对模型来说可能也是如此。一个好的工具定义通常包括使用示例、边缘情况、输入格式要求,以及与其他工具的明确界限。&lt;&#x2F;li&gt;
&lt;li&gt;如何更改参数名称或描述以使事情更明显?把这想象成为团队中的初级开发人员写一个很棒的文档字符串。这在使用多个相似工具时尤其重要。&lt;&#x2F;li&gt;
&lt;li&gt;测试模型如何使用你的工具:在我们的&lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;console.anthropic.com&#x2F;workbench&quot;&gt;工作台&lt;&#x2F;a&gt;中运行多个示例输入,看看模型会犯什么错误,并进行迭代。&lt;&#x2F;li&gt;
&lt;li&gt;对你的工具进行&lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Poka-yoke&quot;&gt;防错&lt;&#x2F;a&gt;设计。更改参数使其更难出错。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;在构建我们的 &lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.anthropic.com&#x2F;research&#x2F;swe-bench-sonnet&quot;&gt;SWE-bench&lt;&#x2F;a&gt; 智能体时,我们实际上花在优化工具上的时间比优化整体提示的时间还多。例如,我们发现当智能体移出根目录后,模型在使用相对文件路径的工具时会出错。为了解决这个问题,我们更改了工具,始终要求使用绝对文件路径——我们发现模型完美地使用了这种方法。&lt;&#x2F;p&gt;
</content>
        
    </entry>
    <entry xml:lang="zh">
        <title>Model Context Protocol 开启AI数据交互新纪元</title>
        <published>2025-01-09T00:00:00+00:00</published>
        <updated>2025-01-09T00:00:00+00:00</updated>
        <author>
          <name>Unknown</name>
        </author>
        <link rel="alternate" href="https://linq.github.io/posts/mcp/" type="text/html"/>
        <id>https://linq.github.io/posts/mcp/</id>
        
        <content type="html">&lt;h2 id=&quot;yi-kai-chang-yin-zi&quot;&gt;一、开场引子&lt;&#x2F;h2&gt;
&lt;p&gt;想象这样的场景：&lt;&#x2F;p&gt;
&lt;p&gt;小王是一名开发者，他正在开发一个智能客服系统。这个系统需要：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;查询公司的产品知识库来回答用户咨询&lt;&#x2F;li&gt;
&lt;li&gt;访问订单系统核实客户的购买记录&lt;&#x2F;li&gt;
&lt;li&gt;连接 CRM 系统了解用户画像&lt;&#x2F;li&gt;
&lt;li&gt;实时获取库存信息…&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;每增加一个数据源，小王就要写一堆接口代码，还要考虑数据格式转换、访问权限等问题。等系统好不容易开发完成，产品经理又提出要接入新的数据源…“这也太痛苦了！“小王抱怨道，“要是有一个统一的标准就好了。”&lt;&#x2F;p&gt;
&lt;p&gt;好消息是，这个统一的标准已经来了 —— Model Context Protocol（以下简称 MCP）。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;linq.github.io&#x2F;posts&#x2F;mcp&#x2F;.&#x2F;mcp_official_definition.png&quot; alt=&quot;MCP官方比喻&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;2024年11月25日，Anthropic 发布了 Model Context Protocol，这是一个划时代的时刻。这个协议的发布标志着 AI 应用开发进入了一个新的阶段。让我们来看看 Anthropic 是如何描述这个协议的：&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;“Model Context Protocol 是一个开源协议，旨在标准化应用程序向大语言模型提供上下文的方式。它就像是 AI 世界的 USB 接口，让不同的数据源和工具能够无缝地与 AI 模型对话。”&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;这个比喻非常贴切。就像 USB 接口让各种电子设备能够轻松连接一样，MCP 让 AI 模型能够轻松获取它需要的任何信息。无论是本地数据库、云端服务，还是第三方 API，通过 MCP，它们都能以统一的方式与 AI 模型进行交互。&lt;&#x2F;p&gt;
&lt;p&gt;就像当年 USB 接口统一了电子设备的连接方式，让我们不用再为各种接口烦恼一样，MCP 正在重塑 AI 应用与数据的连接方式。今天，我很高兴能和各位同事一起探讨这个革命性的协议。无论你是技术开发者，还是产品运营同学，相信接下来的分享都会让你对 AI 应用的未来有一个全新的认识。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;er-mcp-shi-shi-yao&quot;&gt;二、MCP 是什么&lt;&#x2F;h2&gt;
&lt;h3 id=&quot;2-1-guan-fang-ding-yi&quot;&gt;2.1 官方定义&lt;&#x2F;h3&gt;
&lt;p&gt;MCP（Model Context Protocol）是一个开源协议，它标准化了应用程序向大语言模型（LLMs）提供上下文的方式。你可以把 MCP 想象成 AI 应用的 USB-C 接口：就像 USB-C 为设备连接各种外设和配件提供了标准化方式一样，MCP 为 AI 模型连接不同的数据源和工具提供了标准化的方式。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;2-2-tong-su-yi-dong-de-jie-shi&quot;&gt;2.2 通俗易懂的解释&lt;&#x2F;h3&gt;
&lt;p&gt;对于非技术同学，想象一下你有一个万能助手，能帮你找资料、回答问题、处理各种事务。但这个助手要想发挥最大效能，得知道去哪里找它需要的信息，这就好比你让助手去家里书架（本地数据源）找本书，或者去网上图书馆（远程数据源）搜资料。MCP 就像是给这个助手和各种信息源之间搭建的一条 “超级高速公路”，有了它，助手能快速、顺畅地获取所需，给出靠谱答案。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;2-3-ji-zhu-ceng-mian-ding-yi&quot;&gt;2.3 技术层面定义&lt;&#x2F;h3&gt;
&lt;p&gt;从技术角度来看，MCP 本质上是一个开源协议，它为 AI 助手与各类数据系统牵线搭桥，提供一套标准化的接口规范。这意味着，不同公司、不同架构下开发的 AI 应用和五花八门的数据存储，都能依据 MCP 来 “对话”，实现高效的数据交互，让数据流动不再受阻。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;san-llm-gong-ju-diao-yong-de-yan-jin-li-cheng&quot;&gt;三、LLM 工具调用的演进历程&lt;&#x2F;h2&gt;
&lt;p&gt;在深入理解 MCP 之前，让我们先回顾 LLM 工具调用能力的发展历程。这段进化史让我们更能体会 MCP 带来的革新。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;3-1-yuan-sheng-llm-gong-ju-diao-yong-shi-dai-zhi-jie-dan-fan-suo&quot;&gt;3.1 原生 LLM 工具调用时代：直接但繁琐&lt;&#x2F;h3&gt;
&lt;p&gt;想象你在一家“自助烹饪“餐厅：虽然厨师给你准备了食材，但你需要自己动手烹饪每一道菜。这就像早期的 LLM 工具调用：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;开发者需要预定义每个工具（函数）及其参数结构&lt;&#x2F;li&gt;
&lt;li&gt;每次调用都要手动处理请求和响应&lt;&#x2F;li&gt;
&lt;li&gt;工具数量增加时，代码复杂度呈指数级增长&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;pre data-lang=&quot;python&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-python &quot;&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;# 传统工具调用示例
&lt;&#x2F;span&gt;&lt;span&gt;tools = [{
&lt;&#x2F;span&gt;&lt;span&gt;    &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;name&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;: &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;search_product&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;,
&lt;&#x2F;span&gt;&lt;span&gt;    &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;description&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;: &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;搜索产品信息&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;,
&lt;&#x2F;span&gt;&lt;span&gt;    &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;parameters&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;: {
&lt;&#x2F;span&gt;&lt;span&gt;        &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;type&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;: &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;object&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;,
&lt;&#x2F;span&gt;&lt;span&gt;        &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;properties&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;: {
&lt;&#x2F;span&gt;&lt;span&gt;            &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;keyword&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;: {&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;type&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;: &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;string&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;},
&lt;&#x2F;span&gt;&lt;span&gt;            &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;category&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;: {&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;type&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;: &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;string&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;}
&lt;&#x2F;span&gt;&lt;span&gt;        }
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}]
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;# 需要大量样板代码来处理工具调用
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h3 id=&quot;3-2-kuang-jia-feng-zhuang-shi-dai-ti-yan-ti-sheng-dan-reng-bu-gou-ling-huo&quot;&gt;3.2 框架封装时代：体验提升但仍不够灵活&lt;&#x2F;h3&gt;
&lt;p&gt;就像餐厅引入了半自动化设备，LangChain、Vercel AI SDK 等框架的出现让开发者终于不用事事亲力亲为：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;统一的工具定义和管理&lt;&#x2F;li&gt;
&lt;li&gt;自动化的调用执行流程&lt;&#x2F;li&gt;
&lt;li&gt;标准化的结果处理&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;但这种方式仍有局限：所有工具都需要在编译时确定，就像餐厅的设备一旦安装就不能随时更换。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;3-3-yun-han-shu-gong-ju-shi-dai-mai-xiang-dong-tai-diao-yong&quot;&gt;3.3 云函数工具时代：迈向动态调用&lt;&#x2F;h3&gt;
&lt;p&gt;随着 AI 应用场景爆发，开发者需要更灵活的工具管理方式。早期解决方案包括：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;使用 eval 或沙盒执行动态代码（国内的DIFY&#x2F;扣子）&lt;&#x2F;li&gt;
&lt;li&gt;通过重新编译部署来增加工具&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;新兴的工具托管平台（如 Toolhouse）开始提供类云函数服务：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;在线安装&#x2F;卸载工具&lt;&#x2F;li&gt;
&lt;li&gt;运行时动态获取工具列表&lt;&#x2F;li&gt;
&lt;li&gt;自动化执行调用&lt;&#x2F;li&gt;
&lt;li&gt;无需重新部署即可使用新工具&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h3 id=&quot;3-4-mcp-shi-dai-biao-zhun-hua-de-ge-xin&quot;&gt;3.4 MCP 时代：标准化的革新&lt;&#x2F;h3&gt;
&lt;p&gt;MCP 的出现标志着 LLM 工具调用进入标准化时代。它不仅继承了前人的优秀实践，更带来了革命性的改变：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;统一标准&lt;&#x2F;strong&gt;：就像 USB 统一了设备接口，MCP 统一了 AI 工具调用接口&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;即插即用&lt;&#x2F;strong&gt;：通过配置即可动态接入新工具，无需修改代码&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;生态共享&lt;&#x2F;strong&gt;：开发者可以贡献和使用来自全球的工具库&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;安全可控&lt;&#x2F;strong&gt;：标准化的权限和安全机制&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;对技术团队而言，MCP 意味着更高效的开发流程；对产品运营同学而言，则意味着 AI 功能可以更快速地迭代升级。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;si-mcp-de-jia-gou-zu-cheng&quot;&gt;四、MCP 的架构组成&lt;&#x2F;h2&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;linq.github.io&#x2F;posts&#x2F;mcp&#x2F;.&#x2F;mcp-arch.png&quot; alt=&quot;MCP架构&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;h3 id=&quot;4-1-mcp-hosts&quot;&gt;4.1 MCP Hosts&lt;&#x2F;h3&gt;
&lt;p&gt;这是我们直接打交道的部分，相当于助手的 “脸” 和 “嘴巴”。像一些桌面端的 AI 应用（如 Claude Desktop）就是 MCP Hosts，我们通过它输入需求，它把我们的指令传递出去，最后再把结果呈现给我们，是人机交互的关键一环。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;4-2-mcp-clients&quot;&gt;4.2 MCP Clients&lt;&#x2F;h3&gt;
&lt;p&gt;从技术角度讲，这是幕后英雄之一。它负责和服务器建立一对一的连接，就像快递小哥，专门把我们的请求准确无误地送到服务器那里，然后再把服务器返回的数据带回来，保障通信的流畅性，确保每个请求都不迷路。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;4-3-mcp-servers&quot;&gt;4.3 MCP Servers&lt;&#x2F;h3&gt;
&lt;p&gt;这是 “数据调度中心”，轻量级的后端服务程序。它依据 MCP 协议把本地或者远程的资源进行整合、调配，对外公开特定功能，让前端的应用（通过客户端）能够轻松获取到想要的数据，决定了数据从哪里来、怎么来。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;4-4-shu-ju-yuan&quot;&gt;4.4 数据源&lt;&#x2F;h3&gt;
&lt;p&gt;数据源分为本地和远程。本地数据源就是咱们电脑里的文件、数据库等，像我们自己整理的项目文档、本地数据库存储的业务数据；远程服务则像是互联网上各种开放的 APIs，比如一些公开的气象数据接口、金融资讯接口等，它们共同构成了 MCP 取之不尽的信息宝库。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;wu-mcp-ji-zhu-shen-du-jie-xi&quot;&gt;五、MCP 技术深度解析&lt;&#x2F;h2&gt;
&lt;h3 id=&quot;5-1-chuan-shu-ceng-shi-xian&quot;&gt;5.1 传输层实现&lt;&#x2F;h3&gt;
&lt;p&gt;MCP 的传输层为客户端和服务器之间的通信提供了基础设施。它采用 JSON-RPC 2.0 作为传输格式，主要支持以下消息类型：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;typescript&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-typescript &quot;&gt;&lt;code class=&quot;language-typescript&quot; data-lang=&quot;typescript&quot;&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; 请求消息格式
&lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;  jsonrpc: &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;2.0&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;,
&lt;&#x2F;span&gt;&lt;span&gt;  id: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;number &lt;&#x2F;span&gt;&lt;span&gt;| &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;string&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;  method: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;string&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;params&lt;&#x2F;span&gt;&lt;span&gt;?: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;object
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; 响应消息格式
&lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;  jsonrpc: &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;2.0&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;,
&lt;&#x2F;span&gt;&lt;span&gt;  id: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;number &lt;&#x2F;span&gt;&lt;span&gt;| &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;string&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;result&lt;&#x2F;span&gt;&lt;span&gt;?: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;object&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;error&lt;&#x2F;span&gt;&lt;span&gt;?: {
&lt;&#x2F;span&gt;&lt;span&gt;    code: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;number&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    message: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;string&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    data?: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;unknown
&lt;&#x2F;span&gt;&lt;span&gt;  }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;最新版本的MCP 支持以下主要方法类型：&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;生命周期方法&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;ul&gt;
&lt;li&gt;initialize: 初始化连接&lt;&#x2F;li&gt;
&lt;li&gt;notifications&#x2F;initialized: 初始化完成通知&lt;&#x2F;li&gt;
&lt;li&gt;ping: 连接检查&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;工具相关方法&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;ul&gt;
&lt;li&gt;tools&#x2F;list: 获取可用工具列表&lt;&#x2F;li&gt;
&lt;li&gt;tools&#x2F;call: 调用工具&lt;&#x2F;li&gt;
&lt;li&gt;notifications&#x2F;tools&#x2F;list_changed: 工具列表变更通知&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;ol start=&quot;3&quot;&gt;
&lt;li&gt;资源相关方法&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;ul&gt;
&lt;li&gt;resources&#x2F;list: 获取资源列表&lt;&#x2F;li&gt;
&lt;li&gt;resources&#x2F;read: 读取资源内容&lt;&#x2F;li&gt;
&lt;li&gt;resources&#x2F;templates&#x2F;list: 获取资源模板列表&lt;&#x2F;li&gt;
&lt;li&gt;resources&#x2F;subscribe: 订阅资源变更&lt;&#x2F;li&gt;
&lt;li&gt;resources&#x2F;unsubscribe: 取消资源订阅&lt;&#x2F;li&gt;
&lt;li&gt;notifications&#x2F;resources&#x2F;list_changed: 资源列表变更通知&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;ol start=&quot;4&quot;&gt;
&lt;li&gt;提示词相关方法&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;ul&gt;
&lt;li&gt;prompts&#x2F;list: 获取提示词列表&lt;&#x2F;li&gt;
&lt;li&gt;prompts&#x2F;get: 获取特定提示词&lt;&#x2F;li&gt;
&lt;li&gt;notifications&#x2F;prompts&#x2F;list_changed: 提示词列表变更通知&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;ol start=&quot;5&quot;&gt;
&lt;li&gt;日志相关方法&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;ul&gt;
&lt;li&gt;logging&#x2F;setLevel: 设置日志级别&lt;&#x2F;li&gt;
&lt;li&gt;notifications&#x2F;message: 消息通知&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;ol start=&quot;6&quot;&gt;
&lt;li&gt;根目录相关方法&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;ul&gt;
&lt;li&gt;roots&#x2F;list: 获取根目录列表&lt;&#x2F;li&gt;
&lt;li&gt;notifications&#x2F;roots&#x2F;list_changed: 根目录列表变更通知&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;ol start=&quot;7&quot;&gt;
&lt;li&gt;采样相关方法&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;ul&gt;
&lt;li&gt;sampling&#x2F;createMessage: 创建采样消息&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h3 id=&quot;5-2-nei-zhi-chuan-shu-lei-xing&quot;&gt;5.2 内置传输类型&lt;&#x2F;h3&gt;
&lt;p&gt;MCP 提供了两种标准传输实现：&lt;&#x2F;p&gt;
&lt;h4 id=&quot;5-2-1-biao-zhun-shu-ru-shu-chu-stdio&quot;&gt;5.2.1 标准输入输出（stdio）&lt;&#x2F;h4&gt;
&lt;p&gt;适用场景：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;构建命令行工具&lt;&#x2F;li&gt;
&lt;li&gt;实现本地集成&lt;&#x2F;li&gt;
&lt;li&gt;需要简单进程通信&lt;&#x2F;li&gt;
&lt;li&gt;处理 shell 脚本&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;pre data-lang=&quot;typescript&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-typescript &quot;&gt;&lt;code class=&quot;language-typescript&quot; data-lang=&quot;typescript&quot;&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; 服务器端示例
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;const &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;server &lt;&#x2F;span&gt;&lt;span&gt;= new Server({
&lt;&#x2F;span&gt;&lt;span&gt;  name: &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;example-server&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;,
&lt;&#x2F;span&gt;&lt;span&gt;  version: &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;1.0.0&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;
&lt;&#x2F;span&gt;&lt;span&gt;}, {
&lt;&#x2F;span&gt;&lt;span&gt;  capabilities: {}
&lt;&#x2F;span&gt;&lt;span&gt;});
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;const &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;transport &lt;&#x2F;span&gt;&lt;span&gt;= new StdioServerTransport();
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;await &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;server&lt;&#x2F;span&gt;&lt;span&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;connect&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;transport&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h4 id=&quot;5-2-2-fu-wu-qi-fa-song-shi-jian-sse&quot;&gt;5.2.2 服务器发送事件（SSE）&lt;&#x2F;h4&gt;
&lt;p&gt;适用场景：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;只需要服务器到客户端的流式传输&lt;&#x2F;li&gt;
&lt;li&gt;在受限网络环境中工作&lt;&#x2F;li&gt;
&lt;li&gt;实现简单的更新机制&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h3 id=&quot;5-3-xie-yi-jiao-hu-shi-li&quot;&gt;5.3 协议交互示例&lt;&#x2F;h3&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;linq.github.io&#x2F;posts&#x2F;mcp&#x2F;.&#x2F;mcp-lifecycle.png&quot; alt=&quot;MCP声明周期&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;详细传输例子：&lt;&#x2F;p&gt;
&lt;h4 id=&quot;huo-qu-gong-ju-lie-biao&quot;&gt;获取工具列表&lt;&#x2F;h4&gt;
&lt;p&gt;&lt;strong&gt;request&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;json&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-json &quot;&gt;&lt;code class=&quot;language-json&quot; data-lang=&quot;json&quot;&gt;&lt;span&gt;{&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;jsonrpc&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;:&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;2.0&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;,&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;method&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;:&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;tools&#x2F;list&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;,&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;id&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;:&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;11728f1a-2&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;,&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;params&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;:{}}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;&lt;strong&gt;response&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;json&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-json &quot;&gt;&lt;code class=&quot;language-json&quot; data-lang=&quot;json&quot;&gt;&lt;span&gt;{&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;tools&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;:[{&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;name&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;:&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;calculator&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;,&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;description&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;:&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;Performs basic arithmetic operations (add, subtract, multiply, divide)&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;,&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;inputSchema&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;:{&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;type&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;:&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;object&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;,&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;properties&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;:{&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;operation&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;:{&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;type&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;:&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;string&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;,&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;enum&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;:[&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;add&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;,&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;subtract&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;,&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;multiply&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;,&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;divide&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;],&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;description&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;:&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;The arithmetic operation to perform&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;},&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;a&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;:{&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;type&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;:&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;number&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;,&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;description&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;:&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;First operand&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;},&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;b&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;:{&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;type&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;:&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;number&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;,&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;description&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;:&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;Second operand&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;}},&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;required&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;:[&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;operation&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;,&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;a&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;,&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;b&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;]}},{&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;name&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;:&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;weather&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;,&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;description&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;:&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;Weather forecast tool by location&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;,&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;inputSchema&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;:{&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;city&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;:&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;String&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;}}]}}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h4 id=&quot;gong-ju-diao-yong&quot;&gt;工具调用&lt;&#x2F;h4&gt;
&lt;p&gt;&lt;strong&gt;request&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;json&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-json &quot;&gt;&lt;code class=&quot;language-json&quot; data-lang=&quot;json&quot;&gt;&lt;span&gt;{&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;jsonrpc&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;:&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;2.0&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;,&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;method&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;:&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;tools&#x2F;call&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;,&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;id&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;:&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;2040288c-4&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;,&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;params&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;:{&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;name&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;:&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;calculator&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;,&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;arguments&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;:{&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;operation&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;:&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;multiply&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;,&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;b&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;:&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;3.0&lt;&#x2F;span&gt;&lt;span&gt;,&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;a&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;:&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;2.0&lt;&#x2F;span&gt;&lt;span&gt;}}}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;&lt;strong&gt;response&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;json&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-json &quot;&gt;&lt;code class=&quot;language-json&quot; data-lang=&quot;json&quot;&gt;&lt;span&gt;{&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;jsonrpc&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;:&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;2.0&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;,&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;id&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;:&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;e5dc16a9-4&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;,&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;result&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;:{&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;content&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;:[{&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;type&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;:&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;text&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;,&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;text&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;:&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;6.0&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;}],&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;isError&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;:&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;false&lt;&#x2F;span&gt;&lt;span&gt;}}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h3 id=&quot;5-4-zui-jia-shi-jian&quot;&gt;5.4 最佳实践&lt;&#x2F;h3&gt;
&lt;p&gt;技术团队在实施 MCP 时，建议遵循以下最佳实践：&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;生命周期管理&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;正确处理连接生命周期&lt;&#x2F;li&gt;
&lt;li&gt;实现资源清理机制&lt;&#x2F;li&gt;
&lt;li&gt;合理设置超时时间&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;错误处理&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;实现完善的错误处理机制&lt;&#x2F;li&gt;
&lt;li&gt;记录传输事件用于调试&lt;&#x2F;li&gt;
&lt;li&gt;实现重连逻辑&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;性能优化&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;处理消息队列的背压&lt;&#x2F;li&gt;
&lt;li&gt;监控连接健康状态&lt;&#x2F;li&gt;
&lt;li&gt;实现消息验证&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;调试支持&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;启用调试日志&lt;&#x2F;li&gt;
&lt;li&gt;监控消息流&lt;&#x2F;li&gt;
&lt;li&gt;检查连接状态&lt;&#x2F;li&gt;
&lt;li&gt;验证消息格式&lt;&#x2F;li&gt;
&lt;li&gt;测试边缘情况&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;这些技术细节可能对非技术同学来说有些晦涩，但它们正是 MCP 能够支撑企业级 AI 应用的基石。产品经理在规划功能时，可以放心地依赖这些基础设施，专注于业务逻辑的设计。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;liu-mcp-de-he-xin-te-xing-yu-you-shi&quot;&gt;六、MCP 的核心特性与优势&lt;&#x2F;h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;标准化与模块化&lt;&#x2F;strong&gt;：
&lt;ul&gt;
&lt;li&gt;MCP 提供了一种标准化的方式来连接 AI 助手与外部数据源，解决了数据孤岛问题。这种标准化使得开发者可以更轻松地将大型语言模型（LLMs）与各种数据源集成，从而提高开发效率和系统的可扩展性。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;双向安全连接&lt;&#x2F;strong&gt;：
&lt;ul&gt;
&lt;li&gt;MCP 支持安全的双向连接，确保数据在传输过程中的安全性和隐私保护。这对于处理敏感数据尤为重要。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;多场景应用支持&lt;&#x2F;strong&gt;：
&lt;ul&gt;
&lt;li&gt;MCP 不仅支持本地资源的访问，还支持远程资源的访问，包括文件系统、数据库连接、API 集成等。这使得MCP在多种应用场景下都能发挥作用。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;开源与社区支持&lt;&#x2F;strong&gt;：
&lt;ul&gt;
&lt;li&gt;MCP 是一个开源协议，拥有丰富的社区支持和资源库，如本地 MCP 服务器库和开源项目库。这为开发者提供了丰富的工具和文档，降低了开发门槛。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;灵活的架构设计&lt;&#x2F;strong&gt;：
&lt;ul&gt;
&lt;li&gt;MCP 采用客户端-服务器架构，允许 LLMs 以服务请求、大模型请求或一般 Tool 请求的形式调用外部数据源。这种灵活性使得 MCP 能够适应不同的需求和场景。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;h2 id=&quot;qi-ying-yong-chang-jing&quot;&gt;七、应用场景&lt;&#x2F;h2&gt;
&lt;h3 id=&quot;7-1-xing-ye-ying-yong&quot;&gt;7.1 行业应用&lt;&#x2F;h3&gt;
&lt;h4 id=&quot;7-1-1-jin-rong-ke-ji&quot;&gt;7.1.1 金融科技&lt;&#x2F;h4&gt;
&lt;p&gt;在金融科技领域，利用 MCP 优化日常业务流程。比如在处理客户的信贷申请时，AI 通过 MCP 快速整合用户银行流水（本地数据源）、信用评级机构数据（远程数据源），瞬间给出精准的风险评估，大大缩短审批时间，提升客户体验，同时降低了人工审核的误差风险，让金融服务更加智能、高效。&lt;&#x2F;p&gt;
&lt;h4 id=&quot;7-1-2-zi-dong-jia-shi&quot;&gt;7.1.2 自动驾驶&lt;&#x2F;h4&gt;
&lt;p&gt;自动驾驶领域，借助 MCP 整合海量数据。一方面，连接车载传感器实时采集的路况数据（本地），另一方面获取交通部门的实时路况信息（远程），AI 依据 MCP 融合分析，为自动驾驶汽车提供最优决策，像是提前规划避堵路线、应对突发路况，让自动驾驶更安全、可靠。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;7-2-kai-fa-gong-ju-fu-neng&quot;&gt;7.2 开发工具赋能&lt;&#x2F;h3&gt;
&lt;h4 id=&quot;6-2-1-sourcegraph-cody-ying-yong&quot;&gt;6.2.1 Sourcegraph Cody 应用&lt;&#x2F;h4&gt;
&lt;p&gt;作为 MCP 的首批支持者之一，Sourcegraph Cody 展示了 MCP 在开发工具中的强大潜力。通过 MCP，Cody 能够：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;多源数据接入&lt;&#x2F;strong&gt;：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;连接 GitHub 或 Linear 的问题追踪系统&lt;&#x2F;li&gt;
&lt;li&gt;访问 Postgres 数据库进行查询优化&lt;&#x2F;li&gt;
&lt;li&gt;读取内部文档和知识库&lt;&#x2F;li&gt;
&lt;li&gt;所有这些都无需离开 IDE 环境&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;数据库开发助手&lt;&#x2F;strong&gt;：&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;pre data-lang=&quot;typescript&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-typescript &quot;&gt;&lt;code class=&quot;language-typescript&quot; data-lang=&quot;typescript&quot;&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; 示例：Cody 通过 MCP 连接 Postgres 数据库
&lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;  &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;openctx.providers&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;: {
&lt;&#x2F;span&gt;&lt;span&gt;    &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;https:&#x2F;&#x2F;openctx.org&#x2F;npm&#x2F;@openctx&#x2F;provider-modelcontextprotocol&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;: {
&lt;&#x2F;span&gt;&lt;span&gt;      &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;nodeCommand&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;: &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;node&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;,
&lt;&#x2F;span&gt;&lt;span&gt;      &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;mcp.provider.uri&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;: &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;file:&#x2F;&#x2F;&#x2F;path&#x2F;to&#x2F;postgres-server&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;,
&lt;&#x2F;span&gt;&lt;span&gt;      &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;mcp.provider.args&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;: [&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;postgresql:&#x2F;&#x2F;connection-string&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;]
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;  }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;丰富的集成能力&lt;&#x2F;strong&gt;：
&lt;ul&gt;
&lt;li&gt;Brave 搜索 API 集成&lt;&#x2F;li&gt;
&lt;li&gt;Google Drive 文档访问&lt;&#x2F;li&gt;
&lt;li&gt;Git 历史记录分析&lt;&#x2F;li&gt;
&lt;li&gt;本地文件系统访问&lt;&#x2F;li&gt;
&lt;li&gt;SQLite 数据库查询&lt;&#x2F;li&gt;
&lt;li&gt;Web 自动化（通过 Puppeteer）&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;最令人兴奋的是，一旦构建了 MCP 服务器，它就能为多个工具提供上下文支持，不仅限于 Cody。这种标准化的方式让开发者能够更专注于创造性的编码工作，而将繁琐的上下文切换交给 AI 助手处理。&lt;&#x2F;p&gt;
&lt;h4 id=&quot;7-2-2-cloudflare-workers-shi-jian&quot;&gt;7.2.2 Cloudflare Workers 实践&lt;&#x2F;h4&gt;
&lt;p&gt;Cloudflare 通过其 workers-mcp 工具包，大大简化了 MCP 服务器的部署流程。开发者只需几行代码，就能让 AI 助手具备强大的云服务能力。&lt;&#x2F;p&gt;
&lt;h5 id=&quot;kuai-su-bu-shu-shi-li&quot;&gt;快速部署示例&lt;&#x2F;h5&gt;
&lt;pre data-lang=&quot;javascript&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-javascript &quot;&gt;&lt;code class=&quot;language-javascript&quot; data-lang=&quot;javascript&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;import &lt;&#x2F;span&gt;&lt;span&gt;{ &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;WorkerEntrypoint &lt;&#x2F;span&gt;&lt;span&gt;} &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;from &lt;&#x2F;span&gt;&lt;span&gt;&amp;#39;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;cloudflare:workers&lt;&#x2F;span&gt;&lt;span&gt;&amp;#39;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;import &lt;&#x2F;span&gt;&lt;span&gt;{ &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;ProxyToSelf &lt;&#x2F;span&gt;&lt;span&gt;} &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;from &lt;&#x2F;span&gt;&lt;span&gt;&amp;#39;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;workers-mcp&lt;&#x2F;span&gt;&lt;span&gt;&amp;#39;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;export default class &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ebcb8b;&quot;&gt;MyWorker &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;extends &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;WorkerEntrypoint&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;&amp;lt;Env&amp;gt; {
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;**
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;   * 生成图片的示例工具
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;   * &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;@param &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;prompt&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt; {string} 图片描述文本
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;   * &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;@param &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;steps&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt; {number} 扩散步数，数值越高质量越好但耗时更长
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;   *&#x2F;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;async &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;generateImage&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;prompt&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;string, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;steps&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;number&lt;&#x2F;span&gt;&lt;span&gt;): &lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;Promise&amp;lt;string&amp;gt; {
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;const &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;response &lt;&#x2F;span&gt;&lt;span&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;await &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;this&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;env&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;AI&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;run&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span&gt;&amp;#39;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;@cf&#x2F;black-forest-labs&#x2F;flux-1-schnell&lt;&#x2F;span&gt;&lt;span&gt;&amp;#39;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;, {
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;      &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;prompt&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;,
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;      &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;steps&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;,
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;    });
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; 图片处理逻辑...
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;return &lt;&#x2F;span&gt;&lt;span&gt;new &lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;Response(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;img&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;, {
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;      headers: { &lt;&#x2F;span&gt;&lt;span&gt;&amp;#39;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;Content-Type&lt;&#x2F;span&gt;&lt;span&gt;&amp;#39;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;: &lt;&#x2F;span&gt;&lt;span&gt;&amp;#39;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;image&#x2F;jpeg&lt;&#x2F;span&gt;&lt;span&gt;&amp;#39; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;}
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;    });
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;  }
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;async &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;fetch&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;request&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;Request&lt;&#x2F;span&gt;&lt;span&gt;): &lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;Promise&amp;lt;Response&amp;gt; {
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;return &lt;&#x2F;span&gt;&lt;span&gt;new &lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;ProxyToSelf(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;this&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;).&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;fetch&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;request&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;)
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;  }
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h5 id=&quot;feng-fu-de-ying-yong-chang-jing&quot;&gt;丰富的应用场景&lt;&#x2F;h5&gt;
&lt;p&gt;通过 Cloudflare Workers 和 MCP 的结合，可以轻松实现：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;使用 Email Routing 发送自动跟进邮件&lt;&#x2F;li&gt;
&lt;li&gt;通过浏览器自动化捕获和分享网站预览&lt;&#x2F;li&gt;
&lt;li&gt;使用 Durable Objects 存储和管理会话数据&lt;&#x2F;li&gt;
&lt;li&gt;查询和更新 D1 数据库&lt;&#x2F;li&gt;
&lt;li&gt;直接调用已有的 Workers 服务&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h5 id=&quot;kai-fa-you-shi&quot;&gt;开发优势&lt;&#x2F;h5&gt;
&lt;p&gt;与传统开发相比，使用 Workers MCP 服务器具有显著优势：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;无需手动配置服务器实例&lt;&#x2F;li&gt;
&lt;li&gt;不用编写详细的 API 模式定义&lt;&#x2F;li&gt;
&lt;li&gt;自动处理请求路由&lt;&#x2F;li&gt;
&lt;li&gt;简化响应格式化&lt;&#x2F;li&gt;
&lt;li&gt;内置通信配置&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;这种简化的开发方式让产品团队能够快速验证想法，开发团队则可以专注于业务逻辑实现，显著提升了产品迭代效率。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;7-3-geng-duo-ying-yong-chang-jing&quot;&gt;7.3 更多应用场景&lt;&#x2F;h3&gt;
&lt;p&gt;以下是一些官方 MCP 服务器之外的其他一些支持的场景分类:&lt;&#x2F;p&gt;
&lt;p&gt;📂 - 浏览器自动化
🎨 - 艺术与文化
☁️ - 云平台
🖥️ - 命令行工具
💬 - 通讯工具
👤 - 客户数据平台
🗄️ - 数据库
🛠️ - 开发者工具
📂 - 文件系统
💰 - 金融科技
🧠 - 知识与记忆
🗺️ - 位置服务
📊 - 监控系统
🔎 - 搜索服务
🔒 - 安全工具
🚆 - 交通与运输
🔄 - 版本控制
🛠️ - 其他工具与集成&lt;&#x2F;p&gt;
&lt;p&gt;详细参考：&lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;punkpeye&#x2F;awesome-mcp-servers&quot;&gt;awesome-mcp-servers&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;h3 id=&quot;guan-fang-yan-shi&quot;&gt;官方演示&lt;&#x2F;h3&gt;
&lt;p&gt;&lt;a rel=&quot;noopener&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;videocdnv2.ruguoapp.com&#x2F;lq72YoYcy_-UU10nxPGbpPpPiXVE.mp4?sign=684a6ff888d6a62498ae72d465d3aa5f&amp;amp;t=677e4ac9&quot;&gt;MCP 官方演示&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;h2 id=&quot;ba-ipaas-yu-mcp-de-rong-he-fang-an&quot;&gt;八、iPaaS 与 MCP 的融合方案&lt;&#x2F;h2&gt;
&lt;p&gt;在探讨完各种应用场景后，让我们具体看看如何将 iPaaS 与 MCP 结合。我们将分析短期和长期两种实施方案，帮助团队根据实际情况做出选择。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;8-1-duan-qi-fang-an-ipaas-local-server&quot;&gt;8.1 短期方案：iPaaS Local Server&lt;&#x2F;h3&gt;
&lt;p&gt;这种方案通过开发一个本地 MCP 服务器（ipaa-local-server）来桥接 iPaaS 的远程接口。&lt;&#x2F;p&gt;
&lt;h4 id=&quot;8-1-1-jia-gou-she-ji&quot;&gt;8.1.1 架构设计&lt;&#x2F;h4&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;linq.github.io&#x2F;posts&#x2F;mcp&#x2F;.&#x2F;ipaas-local.png&quot; alt=&quot;iPaaS本地&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;h4 id=&quot;8-1-2-shi-xian-shi-li&quot;&gt;8.1.2 实现示例&lt;&#x2F;h4&gt;
&lt;pre data-lang=&quot;typescript&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-typescript &quot;&gt;&lt;code class=&quot;language-typescript&quot; data-lang=&quot;typescript&quot;&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; iPaaS Local Server 实现示例
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;import &lt;&#x2F;span&gt;&lt;span&gt;{ &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;McpServer&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;StdioTransport &lt;&#x2F;span&gt;&lt;span&gt;} &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;from &lt;&#x2F;span&gt;&lt;span&gt;&amp;#39;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;@anthropic-ai&#x2F;mcp&lt;&#x2F;span&gt;&lt;span&gt;&amp;#39;;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;class &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ebcb8b;&quot;&gt;IPaaSLocalServer &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;extends &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;McpServer &lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;{
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;private &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;apiClient&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;IPaaSAPIClient;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;private &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;cache&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;LocalCache;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;constructor&lt;&#x2F;span&gt;&lt;span&gt;() &lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;{
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;super&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;({
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;      name: &lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;ipaas-local-server&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;,
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;      version: &lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;1.0.0&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;    });
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;    
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;this&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;apiClient &lt;&#x2F;span&gt;&lt;span&gt;= new &lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;IPaaSAPIClient({
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;      baseURL: &lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;https:&#x2F;&#x2F;api.ipaas.example.com&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;,
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;      apiKey: process.env.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;IPAAS_API_KEY
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;    });
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;    
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;this&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;cache &lt;&#x2F;span&gt;&lt;span&gt;= new &lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;LocalCache();
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;  }
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; 注册 iPaaS API 为 MCP 工具
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;async &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;registerIPaaSTools&lt;&#x2F;span&gt;&lt;span&gt;() &lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;{
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;const &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;apis &lt;&#x2F;span&gt;&lt;span&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;await &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;this&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;apiClient&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;listAPIs&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;();
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;apis&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;forEach&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;api &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;=&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;{
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;      &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;this&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;registerTool&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;({
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;        name: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;api&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;.name,
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;        description: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;api&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;.description,
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;handler&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;async &lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;params&lt;&#x2F;span&gt;&lt;span&gt;) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;=&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;{
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;          &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; 检查缓存
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;          &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;const &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;cachedResult &lt;&#x2F;span&gt;&lt;span&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;await &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;this&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;cache&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;get&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;api&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;.name, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;params&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;);
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;          &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if &lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;cachedResult&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;return &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;cachedResult&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;          &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; 调用远程 API
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;          &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;const &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;result &lt;&#x2F;span&gt;&lt;span&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;await &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;this&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;apiClient&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;call&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;api&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;.name, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;params&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;);
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;          
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;          &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; 更新缓存
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;          &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;await &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;this&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;cache&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;set&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;api&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;.name, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;params&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;result&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;);
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;          
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;          &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;return &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;result&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;        }
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;      });
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;    });
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;  }
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; 启动服务器
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;const &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;server &lt;&#x2F;span&gt;&lt;span&gt;= new IPaaSLocalServer();
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;const &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;transport &lt;&#x2F;span&gt;&lt;span&gt;= new StdioTransport();
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;server&lt;&#x2F;span&gt;&lt;span&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;connect&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;transport&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h4 id=&quot;8-1-3-you-shi&quot;&gt;8.1.3 优势&lt;&#x2F;h4&gt;
&lt;ul&gt;
&lt;li&gt;本地化优势：解决身份验证与授权问题&lt;&#x2F;li&gt;
&lt;li&gt;缓存机制：可以实现本地缓存，减少 API 调用&lt;&#x2F;li&gt;
&lt;li&gt;安全性：敏感数据可以本地处理，不需要暴露到云端&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h4 id=&quot;8-1-4-ju-xian-xing&quot;&gt;8.1.4 局限性&lt;&#x2F;h4&gt;
&lt;ul&gt;
&lt;li&gt;维护成本：需要在每个客户端部署和更新本地服务器&lt;&#x2F;li&gt;
&lt;li&gt;使用方式：本地server基于标准输入输出，需要使用子进程方式调用，端测不一定能支持&lt;&#x2F;li&gt;
&lt;li&gt;一致性问题：本地缓存可能导致数据不一致，部分需要实时性的功能可能无法很好支持&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h3 id=&quot;8-2-chang-qi-fang-an-ipaas-native-mcp-server&quot;&gt;8.2 长期方案：iPaaS Native MCP Server&lt;&#x2F;h3&gt;
&lt;p&gt;这种方案将 MCP Server 直接集成到 iPaaS 平台中，通过 SSE（Server-Sent Events）提供服务。&lt;&#x2F;p&gt;
&lt;h4 id=&quot;8-2-1-jia-gou-she-ji&quot;&gt;8.2.1 架构设计&lt;&#x2F;h4&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;linq.github.io&#x2F;posts&#x2F;mcp&#x2F;.&#x2F;ipaas-remote.png&quot; alt=&quot;iPaaS本地&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;h4 id=&quot;8-2-2-shi-xian-shi-li&quot;&gt;8.2.2 实现示例&lt;&#x2F;h4&gt;
&lt;pre data-lang=&quot;typescript&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-typescript &quot;&gt;&lt;code class=&quot;language-typescript&quot; data-lang=&quot;typescript&quot;&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; iPaaS Native MCP Server 实现示例
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;class &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ebcb8b;&quot;&gt;IPaaSNativeMcpServer &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;extends &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;McpServer &lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;{
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;constructor&lt;&#x2F;span&gt;&lt;span&gt;() &lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;{
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;super&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;({
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;      name: &lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;ipaas-native-mcp&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;,
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;      version: &lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;1.0.0&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;,
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;      transport: &lt;&#x2F;span&gt;&lt;span&gt;new &lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;SSETransport({
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;        keepAlive: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;true&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;,
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;        reconnectDelay: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1000
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;      })
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;    });
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;  }
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; 实时注册新的 API
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;  @&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;Subscribe&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span&gt;&amp;#39;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;api.new&lt;&#x2F;span&gt;&lt;span&gt;&amp;#39;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;)
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;async &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;onNewAPI&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;api&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;APIDefinition&lt;&#x2F;span&gt;&lt;span&gt;) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;{
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;await &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;this&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;registerTool&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;({
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;      name: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;api&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;.name,
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;      description: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;api&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;.description,
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;      &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;handler&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;async &lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;params&lt;&#x2F;span&gt;&lt;span&gt;) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;=&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;{
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; 直接调用内部 API
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;return await &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;this&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;internalCall&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;api&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;.name, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;params&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;);
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;      }
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;    });
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;    
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; 广播工具列表更新
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;this&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;broadcast&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span&gt;&amp;#39;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;tools&#x2F;list_changed&lt;&#x2F;span&gt;&lt;span&gt;&amp;#39;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;);
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;  }
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; 实时监控和分析
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;  @&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;Monitor&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;()
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;async &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;onToolCall&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;tool&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;string, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;params&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;any&lt;&#x2F;span&gt;&lt;span&gt;) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;{
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;await &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;Analytics&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;log&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;({
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;      &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;tool&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;,
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;      &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;params&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;,
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;      timestamp: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ebcb8b;&quot;&gt;Date&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;now&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;()
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;    });
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;  }
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h4 id=&quot;8-2-3-you-shi&quot;&gt;8.2.3 优势&lt;&#x2F;h4&gt;
&lt;ul&gt;
&lt;li&gt;原生集成：作为平台原生功能，维护成本低&lt;&#x2F;li&gt;
&lt;li&gt;实时性好：支持实时更新和双向通信&lt;&#x2F;li&gt;
&lt;li&gt;集中管理：统一的监控、计费和权限控制&lt;&#x2F;li&gt;
&lt;li&gt;扩展性强：可以快速添加新功能和集成新服务&lt;&#x2F;li&gt;
&lt;li&gt;一致性好：所有客户端访问相同的服务端点&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h4 id=&quot;8-2-4-ju-xian-xing&quot;&gt;8.2.4 局限性&lt;&#x2F;h4&gt;
&lt;ul&gt;
&lt;li&gt;协议限制：依赖MCP协议的支持，包括身份验证与授权等能力的支持&lt;&#x2F;li&gt;
&lt;li&gt;网络依赖：需要网关支持SSE方式，同时数据包符合标准JSON-RPC 2.0数据格式&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h3 id=&quot;8-3-fang-an-xuan-ze-jian-yi&quot;&gt;8.3 方案选择建议&lt;&#x2F;h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;短期方案适用场景&lt;&#x2F;strong&gt;：
&lt;ul&gt;
&lt;li&gt;需要快速验证 MCP 集成效果&lt;&#x2F;li&gt;
&lt;li&gt;本地化需求强烈的场景&lt;&#x2F;li&gt;
&lt;li&gt;对数据隐私要求较高的场景&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;长期方案适用场景&lt;&#x2F;strong&gt;：
&lt;ul&gt;
&lt;li&gt;企业级应用部署&lt;&#x2F;li&gt;
&lt;li&gt;需要统一管理和监控&lt;&#x2F;li&gt;
&lt;li&gt;实时性要求高的场景&lt;&#x2F;li&gt;
&lt;li&gt;规模化部署需求&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;过渡策略&lt;&#x2F;strong&gt;：
&lt;ul&gt;
&lt;li&gt;可以先采用短期方案快速验证&lt;&#x2F;li&gt;
&lt;li&gt;同时启动长期方案的规划和开发&lt;&#x2F;li&gt;
&lt;li&gt;待长期方案成熟后平滑迁移&lt;&#x2F;li&gt;
&lt;li&gt;保持两种方案的兼容性&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;h2 id=&quot;jiu-ji-zhu-tiao-zhan-yu-jing-zheng&quot;&gt;九、技术挑战与竞争&lt;&#x2F;h2&gt;
&lt;h3 id=&quot;9-1-ji-zhu-tiao-zhan&quot;&gt;9.1 技术挑战&lt;&#x2F;h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;标准化与兼容性&lt;&#x2F;strong&gt;：
MCP 试图通过标准化接口实现 LLM 与各种数据源的无缝连接，但这一过程并不容易。目前市场上存在多个竞争协议，如 LangChain、API Gateway 等，这些协议在功能和性能上各有优劣，使得 MCP 的标准化之路充满挑战。此外，不同数据源的多样性和复杂性也增加了实现统一标准的难度。&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;性能与安全性&lt;&#x2F;strong&gt;：
MCP 协议需要在保证数据安全的同时，提升模型的响应速度和处理能力。然而，在大规模数据处理和高并发请求场景下，其性能表现仍需进一步验证。此外，如何在开放环境中有效保护用户数据隐私也是一个重要问题。&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;生态系统的构建与推广&lt;&#x2F;strong&gt;：
MCP 的成功不仅依赖于技术本身，还需要广泛的社区支持和开发者网络。然而，目前市场上已有多个竞争协议，这可能导致生态系统的分裂，从而影响 MCP 的普及速度和市场接受度。&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;适配不同数据源的能力&lt;&#x2F;strong&gt;：
尽管 MCP 支持多种数据形式的交换，包括文件内容、数据库记录、API 响应等，但如何高效地适配不同类型的外部数据源仍是一个技术难题。此外，如何确保在不同场景下数据的一致性和质量也是需要解决的问题。&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;h3 id=&quot;9-2-jing-zheng-tiao-zhan&quot;&gt;9.2 竞争挑战&lt;&#x2F;h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;与其他协议的竞争&lt;&#x2F;strong&gt;：
目前市场上已有多个协议试图解决类似问题，如 LangChain、API Gateway 等。这些协议在功能、开放性和生态系统建设方面各有优势，使得 MCP 面临激烈的市场竞争。此外，由于市场上存在多达 14 个竞争协议，MCP 能否成为通用标准仍是一个未知数。&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;开发者接受度与生态建设&lt;&#x2F;strong&gt;：
MCP 虽然已经开源并吸引了部分企业（如 Block、Apache）的支持，但其普及仍需时间。开发者对新技术的接受度以及如何构建一个健康的生态系统是 MCP 面临的重要挑战。如果开发者对 MCP 的未来持怀疑态度，可能会导致其难以获得广泛认可。&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;技术开放性与商业利益的平衡&lt;&#x2F;strong&gt;：
MCP 的开放性使其能够吸引更多的开发者和企业参与，但这也可能引发一些大型科技公司（如谷歌、微软）的担忧。这些公司可能会通过自己的技术路线或合作模式来对抗 MCP，从而影响其市场地位。&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;h2 id=&quot;shi-wei-lai-zhan-wang&quot;&gt;十、未来展望&lt;&#x2F;h2&gt;
&lt;h3 id=&quot;10-1-duan-qi-tiao-zhan-yu-xian-shi-kao-liang&quot;&gt;10.1 短期挑战与现实考量&lt;&#x2F;h3&gt;
&lt;p&gt;虽然 MCP 的愿景令人振奋,但我们也需要保持理性认识:&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;标准化进程的挑战&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;制定一个被广泛接受的协议是个缓慢的过程&lt;&#x2F;li&gt;
&lt;li&gt;面临的不仅是技术问题,更多是商业层面的考量&lt;&#x2F;li&gt;
&lt;li&gt;大型科技公司(如 OpenAI、Apple)是否会接入仍是未知数&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;过渡期的适应&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;目前的 Computer Use 等技术仍将在过渡期发挥作用&lt;&#x2F;li&gt;
&lt;li&gt;需要时间让开发者和企业逐步适应新范式&lt;&#x2F;li&gt;
&lt;li&gt;基础设施建设和工具链完善需要持续投入&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;h3 id=&quot;10-2-chang-qi-jie-zhi-yu-fa-zhan-qian-li&quot;&gt;10.2 长期价值与发展潜力&lt;&#x2F;h3&gt;
&lt;p&gt;从长远来看,MCP 的技术路线具有深远的战略意义:&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;智能体网络的基石&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;AI 之间通过协议连接成网络是必然趋势&lt;&#x2F;li&gt;
&lt;li&gt;智能体可能实现自组网、自主协商通信协议&lt;&#x2F;li&gt;
&lt;li&gt;有望催生出一个全新的、有别于现有互联网的智能网络生态&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;开放生态的演进&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;开放性是协议发展的核心要素&lt;&#x2F;li&gt;
&lt;li&gt;去中心化的信任机制将得到更多重视&lt;&#x2F;li&gt;
&lt;li&gt;社区驱动的创新将持续涌现&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;技术融合与创新&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;与区块链、DID(去中心化身份)等新兴技术的结合&lt;&#x2F;li&gt;
&lt;li&gt;边缘计算助力数据处理本地化&lt;&#x2F;li&gt;
&lt;li&gt;AI 驱动的协议优化与进化&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;h3 id=&quot;10-3-sheng-tai-jian-she-zhan-wang&quot;&gt;10.3 生态建设展望&lt;&#x2F;h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;多方参与的开放生态&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;开源社区的持续贡献&lt;&#x2F;li&gt;
&lt;li&gt;学术界的理论突破&lt;&#x2F;li&gt;
&lt;li&gt;企业界的实践创新&lt;&#x2F;li&gt;
&lt;li&gt;标准化组织(如 W3C、IEEE)的规范制定&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;应用场景的拓展&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;从单一工具调用到复杂场景协同&lt;&#x2F;li&gt;
&lt;li&gt;跨平台、跨设备的无缝协作&lt;&#x2F;li&gt;
&lt;li&gt;企业级应用的深度整合&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;发展建议&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;保持开放心态,关注协议演进&lt;&#x2F;li&gt;
&lt;li&gt;在保证安全的前提下推动创新&lt;&#x2F;li&gt;
&lt;li&gt;重视实践反馈,持续优化方案&lt;&#x2F;li&gt;
&lt;li&gt;加强社区协作,共建生态体系&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;MCP 的未来发展将是一个循序渐进的过程。虽然短期内可能难以达到一些过于乐观的预期,但从长远来看,它代表了 AI 与数据交互的重要发展方向。无论是技术团队还是产品运营,都需要以更务实的心态参与其中,在实践中不断探索和完善,共同推动这项革新性技术的成熟与普及。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;shi-yi-zong-jie-yu-da-yi&quot;&gt;十一、总结与答疑&lt;&#x2F;h2&gt;
&lt;p&gt;今天我们全方位了解了 MCP，从基础概念、架构原理，到实战优势、挑战应对以及未来潜力。希望大家都收获满满，现在开放答疑环节，不管是技术细节、应用思路还是未来畅想，欢迎大家畅所欲言，一起碰撞出更多智慧火花！&lt;&#x2F;p&gt;
</content>
        
    </entry>
</feed>
